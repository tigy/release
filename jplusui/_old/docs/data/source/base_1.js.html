<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>base_1.js 源码</title>
		<link href="../../assets/styles/prettify.css" type="text/css" rel="stylesheet" />
		<script src="../../assets/scripts/prettify.js" type="text/javascript"></script>
		<style type="text/css">.highlight { display: block; background-color: #ddd; }</style>
</head>
<body onload="setTimeout('prettyPrint()', 0);var node = document.getElementById(location.hash.replace(/#/, ''));if(node)node.className = 'highlight';"><pre class="prettyprint lang-js">/**
 * @fileOverview 提供最底层的 DOM 辅助函数。
 * @pragma defaultExtends System.Base
 */

// Core - 核心部分
// Parse - 节点解析部分
// Traversing - 节点转移部分
// Manipulation - 节点处理部分
// Style - CSS部分
// Attribute - 属性部分
// Event - 事件部分
// DomReady - 加载部分
// Dimension - 尺寸部分
// Offset - 定位部分

(function(window) {
	
	assert(!window.Dom || window.$ != window.Dom.get, &quot;重复引入 System.Dom.Base 模块。&quot;);

	/**
	 * document 简写。
	 * @type Document
	 */
	var document = window.document,
	
		/**
		 * Object 简写。
		 * @type Object
		 */
		Object = window.Object,
	
		/**
		 * Object.extend 简写。
		 * @type Function
		 */
		extend = Object.extend,
	
		/**
		 * 数组原型。
		 * @type Object
		 */
		ap = Array.prototype,
	
		/**
		 * Object.map 缩写。
		 * @type Object
		 */
		map = Object.map,

		/**
		 * System 简写。
		 * @type Object
		 */
		System = window.System,
	
		/**
		 * 指示当前浏览器是否为标签浏览器。
		 */
		isStd = navigator.isStd,
	
		<span id="Dom">/**
		 * 提供对单一原生 HTML 节点的封装操作。
		 * @class
		 * @remark 
		 * @see DomList
		 * @see Dom.get
		 * @see Dom.query
		 * @remark
		 * 所有 DOM 方法都是依赖于此类进行的。比如如下 HTML 代码:
		 * &lt;pre&gt;
		 * &amp;lt;div id=&quot;myDivId&quot;&amp;gt;内容&amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 * 现在如果要操作这个节点，必须获取这个节点对应的 **Dom** 对象实例。
		 * 最常用的创建 **Dom** 对象实例的方法是 {@link Dom.get}。如:
		 * &lt;pre&gt;
		 * var myDiv = Dom.get(&quot;myDivId&quot;);
		 * 
		 * myDiv.addClass(&quot;cssClass&quot;);
		 * &lt;/pre&gt;
		 * 其中，myDiv就是一个 **Dom** 对象。然后通过 **Dom** 对象提供的方法可以方便地操作这个节点。&lt;br&gt;
		 * myDiv.dom 属性就是这个 Dom 对象对应的原生 HTML 节点。即:
		 * &lt;pre&gt;
		 * Dom.get(&quot;myDivId&quot;).dom === document.getElementById(&quot;myDivId&quot;);
		 * &lt;/pre&gt;
		 * 
		 * **Dom** 类仅实现了对一个节点的操作，如果需要同时处理多个节点，可以使用 {@link DomList} 类。
		 * 	{@link DomList} 类的方法和 **Dom** 类的方法基本一致。
		 */</span>
		Dom = Class({
			
			<span id="Dom-prototype-dom">/**
			 * 获取当 Dom 对象实际对应的 HTML 节点实例。
			 * @type Node
			 * @protected
			 */</span>
			dom: null,
			
			<span id="Dom-prototype-dataField">/**
			 * 获取当前类对应的数据字段。
			 * @protected override
			 * @return {Object} 一个可存储数据的对象。
			 * @remark
			 * 此函数会在原生节点上创建一个 $data 属性以存储数据。
			 */</span>
			dataField: function(){
				
				// 由于 IE 6/7 即将退出市场。此处忽略 IE 6/7 内存泄露问题。
				return this.dom.$data || (this.dom.$data = {});
			},
		
			<span id="Dom-prototype-constructor">/**
			 * 使用一个原生节点初始化 Dom 对象的新实例。
			 * @param {Node} dom 封装的元素。
			 */</span>
			constructor: function (dom) {
				assert.isNode(dom, &quot;Dom.prototype.constructor(dom): {dom} 必须是 DOM 节点。&quot;);
				this.dom = dom;
			},
		
			<span id="Dom-prototype-attach">/**
			 * 将当前 Dom 对象插入到指定父 Dom 对象指定位置。
			 * @param {Node} parentNode 要添加的父节点。
			 * @param {Node} refNode=null 如果指定了此值，则当前节点将添加到此节点之前。
			 * @protected virtual
			 */</span>
			attach: function(parentNode, refNode) {
				assert(parentNode &amp;&amp; parentNode.nodeType, 'Dom.prototype.attach(parentNode, refNode): {parentNode} 必须是 DOM 节点。', parentNode);
				assert(refNode === null || refNode.nodeType, 'Dom.prototype.attach(parentNode, refNode): {refNode} 必须是 null 或 DOM 节点 。', refNode);
				parentNode.insertBefore(this.dom, refNode);
			},
		
			<span id="Dom-prototype-detach">/**
			 * 将当前 Dom 对象从指定的父 Dom 对象移除。
			 * @param {Node} parentNode 用于移除的父节点。
			 * @protected virtual
			 */</span>
			detach: function(parentNode) {
				assert(parentNode &amp;&amp; parentNode.removeChild, 'Dom.prototype.detach(parentNode): {parentNode} 必须是 DOM 节点 Dom 对象。', parent);
				parentNode.removeChild(this.dom);
			},
		
			<span id="Dom-prototype-insertBefore">/**
			 * 在当前 Dom 对象下插入一个子 Dom 对象到指定位置。
			 * @param {Dom} childControl 要插入 Dom 对象。
			 * @param {Dom} refControl=null 如果指定了此值，则插入到 Dom 对象之前。
			 * @protected virtual
			 */</span>
			insertBefore: function(childControl, refControl) {
				assert(childControl &amp;&amp; childControl.attach, 'Dom.prototype.insertBefore(childControl, refControl): {childControl} 必须 Dom 对象。', childControl);
				childControl.attach(this.dom, refControl &amp;&amp; refControl.dom || null);
			},
		
			<span id="Dom-prototype-removeChild">/**
			 * 删除当 Dom 对象的指定 Dom 对象。
			 * @param {Dom} childControl 要删除 Dom 对象。
			 * @protected virtual
			 */</span>
			removeChild: function(childControl) {
				assert(childControl &amp;&amp; childControl.detach, 'Dom.prototype.removeChild(childControl): {childControl} 必须 Dom 对象。', childControl);
				childControl.detach(this.dom);
			}
			
		}),
	
		<span id="DomList">/**
		 * 表示原生节点的集合。用于批量操作节点。
		 * @class
		 * @extends Array
		 * @see Dom
		 * @see Dom.query
		 * @remark
		 * **DomList** 是对元素列表的包装。  **DomList** 允许快速操作多个节点。 
		 * {@link Dom} 的所有方法对 **DomList** 都有效。
		 * 要查询 DomList 的方法，可以转到 {@link Dom} 类。
		 * 
		 * **DomList** 是一个伪数组，每个元素都是一个原生的 HTML 节点。
		 */</span>
		DomList = Class({
	
			<span id="DomList-prototype-length">/**
			 * 获取当前集合的节点个数。
			 * @type {Number}
			 * @property
			 */</span>
			length: 0,

		    <span id="DomList-prototype-invoke">/**
			 * 对当前集合的每个节点的 Dom 封装调用其指定属性名的函数，并将返回值放入新的数组返回。
			 * @param {String} fnName 要调用的函数名。
			 * @param {Array} args 调用时的参数数组。
			 * @return {Array} 返回包含执行结果的数组。
			 * @see Array#see
			 */</span>
			invoke: function(fnName, args) {
				assert(args &amp;&amp; typeof args.length === 'number', &quot;DomList.prototype.invoke(fnName, args): {args} 必须是数组, 无法省略。&quot;, args);
				var r = [];
				assert(Dom.prototype[fnName] &amp;&amp; Dom.prototype[fnName].apply, &quot;DomList.prototype.invoke(fnName, args): Dom 不包含方法 {fnName}。&quot;, fnName);
				ap.forEach.call(this, function(value) {
					value = new Dom(value);
					r.push(value[fnName].apply(value, args));
				});
				return r;
			},
			
			<span id="DomList-prototype-constructor">/**
			 * 使用包含节点的数组初始化 DomList 类的新实例。
			 * @param {Array/DomList} [nodes] 用于初始化当前集合的节点集合。
			 * @constructor
			 */</span>
			constructor: function(nodes) {
	
				if(nodes) {

					assert(nodes.length !== undefined, 'DomList.prototype.constructor(nodes): {nodes} 必须是一个 DomList 或 Array 类型的变量。', nodes);
					
					var node;
					
					while(node = nodes[this.length]) {
						this[this.length++] = node.dom || node;	
					}

				}

			},
	
		    <span id="DomList-prototype-item">/**
			 * 获取当前集合中指定索引对应的 Dom 对象。
			 * @param {Number} index 要获取的元素索引。如果 *index* 小于 0， 则表示获取倒数 *index* 位置的元素。
			 * @return {Object} 指定位置所在的元素。如果指定索引的值不存在，则返回 undefined。
			 * @remark
			 * 使用 arr.item(-1) 可获取最后一个元素的值。
			 * @see Array#see
			 * @example 
			 * &lt;pre&gt;
		     * [0, 1, 2, 3].item(0);  // 0
		     * [0, 1, 2, 3].item(-1); // 3
		     * [0, 1, 2, 3].item(5);  // undefined
		     * &lt;/pre&gt;
			 */</span>
			item: function(index){
				var elem = this[index &lt; 0 ? this.length + index : index];
				return elem ? new Dom(elem) : null;
			},
			
			<span id="DomList-prototype-concat">/**
			 * 将参数节点添加到当前集合。
			 * @param {Node/NodeList/Array/DomList} ... 要增加的节点。
			 * @return this
			 */</span>
			concat: function() {
				for(var args = arguments, i = 0; i &lt; args.length; i++){
					var value = args[i], j = -1;
					if(value){
						if(typeof value.length !== 'number')
							value = [value];
							
						while(++j &lt; value.length)
							this.include(value[j].dom || value[j]);
					}
				}
	
				return this;
			}
	
		}),
	
		<span id="Point">/**
		 * 表示一个点。包含 x 坐标和 y 坐标。
		 * @class Point
		 */</span>
		Point = Class({
			
			<span id="Point-prototype-x">/**
			 * @field {Number} x X 坐标。
			 */</span>
			
			<span id="Point-prototype-y">/**
			 * @field {Number} y Y 坐标。
			 */</span>
	
			<span id="Point-prototype-constructor">/**
			 * 初始化 Point 的新实例。
			 * @param {Number} x X 坐标。
			 * @param {Number} y Y 坐标。
			 * @constructor
			 */</span>
			constructor: function(x, y) {
				this.x = x;
				this.y = y;
			},
			
			<span id="Point-prototype-add">/**
			 * 将当前值加上 *p*。
			 * @param {Point} p 值。
			 * @return {Point} this
			 */</span>
			add: function(p) {
				assert(p &amp;&amp; 'x' in p &amp;&amp; 'y' in p, &quot;Point.prototype.add(p): {p} 必须有 'x' 和 'y' 属性。&quot;, p);
				return new Point(this.x + p.x, this.y + p.y);
			},

			<span id="Point-prototype-sub">/**
			 * 将当前值减去 *p*。
			 * @param {Point} System 值。
			 * @return {Point} this
			 */</span>
			sub: function(p) {
				assert(p &amp;&amp; 'x' in p &amp;&amp; 'y' in p, &quot;Point.prototype.sub(p): {p} 必须有 'x' 和 'y' 属性。&quot;, p);
				return new Point(this.x - p.x, this.y - p.y);
			}
		}),
		
		/**
		 * 用于测试的元素。
		 * @type Element
		 */
		div = document.createElement('DIV'),
	
		/**
		 * 函数 Dom.parseNode使用的新元素缓存。
		 * @type Object
		 */
		cache = {},
		
		/**
		 * 样式表。
		 * @static
		 * @type Object
		 */
		sizeMap = {},
		
		/**
		 * 默认事件。
		 * @type Object
		 * @ignore
		 */
		eventObj = {

			/**
			 * 创建当前事件可用的参数。
			 * @param {Dom} ctrl 事件所有者。
			 * @param {Event} e 事件参数。
			 * @param {Object} target 事件目标。
			 * @return {Event} e 事件参数。
			 */
			trigger: function (ctrl, type, fn, e) {
				ctrl = ctrl.dom;

				// IE 8- 在处理原生事件时肯能出现错误。
				try {
					if (!e || !e.type) {
						e = new Dom.Event(ctrl, type, e);
					}
				} catch (ex) {
					e = new Dom.Event(ctrl, type);
				}

				return fn(e) &amp;&amp; (!ctrl[type = 'on' + type] || ctrl[type](e) !== false);
			},

			/**
			 * 添加绑定事件。
			 * @param {Dom} ctrl 事件所有者。
			 * @param {String} type 类型。
			 * @param {Function} fn 函数。
			 */
			add: div.addEventListener ? function (elem, type, fn) {
				elem.dom.addEventListener(type, fn, false);
			} : function (elem, type, fn) {
				elem.dom.attachEvent('on' + type, fn);
			},

			/**
			 * 删除事件。
			 * @param {Object} elem 对象。
			 * @param {String} type 类型。
			 * @param {Function} fn 函数。
			 */
			remove: div.removeEventListener ? function (elem, type, fn) {
				elem.dom.removeEventListener(elem, fn, false);
			} : function (elem, type, fn) {
				elem.dom.detachEvent('on' + type, fn);
			}

		},

		/**
		 * 处理 &lt;div/&gt; 格式标签的正则表达式。
		 * @type RegExp
		 */
		rXhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/ig,
		
		/// #if CompactMode
		
		/**
		 * 透明度的正则表达式。
		 * @type RegExp IE8 使用滤镜支持透明度，这个表达式用于获取滤镜内的表示透明度部分的子字符串。
		 */
		rOpacity = /opacity=([^)]*)/,
		
		/// #endif
		
		/**
		 * 是否属性的正则表达式。
		 * @type RegExp
		 */
		rStyle = /-(\w)|float/,
		
		/**
		 * 判断 body 节点的正则表达式。
		 * @type RegExp
		 */
		rBody = /^(?:BODY|HTML|#document)$/i,
		
		/**
		 * 在 Dom.parseNode 和 setHtml 中对 HTML 字符串进行包装用的字符串。
		 * @type Object 部分元素只能属于特定父元素， tagFix 列出这些元素，并使它们正确地添加到父元素中。 IE678
		 *       会忽视第一个标签，所以额外添加一个 div 标签，以保证此类浏览器正常运行。
		 */
		tagFix = {
			$default: isStd ? [1, '', '']: [2, '$&lt;div&gt;', '&lt;/div&gt;'],
			option: [2, '&lt;select multiple=&quot;multiple&quot;&gt;', '&lt;/select&gt;'],
			legend: [2, '&lt;fieldset&gt;', '&lt;/fieldset&gt;'],
			thead: [2, '&lt;table&gt;', '&lt;/table&gt;'],
			tr: [3, '&lt;table&gt;&lt;tbody&gt;', '&lt;/tbody&gt;&lt;/table&gt;'],
			td: [4, '&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;', '&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;'],
			col: [3, '&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;', '&lt;/colgroup&gt;&lt;/table&gt;'],
			area: [2, '&lt;map&gt;', '&lt;/map&gt;']
		},
		
		styleFix = {
			height: 'setHeight',
			width: 'setWidth'
		},
	
		/**
		 * 特殊属性的列表。
		 * @type Object
		 */
		attrFix = {
			innerText: 'innerText' in div ? 'innerText': 'textContent',
			'for': 'htmlFor',
			'class': 'className'
		},
		
		/**
		 * 字符串字段。
		 * @type Object
		 */
		textFix = {
			
		},
		
		/// #if CompactMode
		 
		/**
		 * 获取元素的实际的样式属性。
		 * @param {Element} elem 需要获取属性的节点。
		 * @param {String} name 需要获取的CSS属性名字。
		 * @return {String} 返回样式字符串，肯能是 undefined、 auto 或空字符串。
		 */
		getStyle = window.getComputedStyle ? function(elem, name) {
	
			// getComputedStyle为标准浏览器获取样式。
			assert.isElement(elem, &quot;Dom.getStyle(elem, name): {elem} ~&quot;);
	
			// 获取真实的样式owerDocument返回elem所属的文档对象
			// 调用getComputeStyle的方式为(elem,null)
			var computedStyle = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
	
			// 返回 , 在 火狐如果存在 IFrame， 则 computedStyle == null
			// http://drupal.org/node/182569
			return computedStyle ? computedStyle[name]: null;
	
		}: function(elem, name) {
	
			assert.isElement(elem, &quot;Dom.getStyle(elem, name): {elem} ~&quot;);
	
			// 特殊样式保存在 styleFix 。
			if( name in styleFix) {
				switch (name) {
					case 'height':
						return elem.offsetHeight === 0 ? 'auto': elem.offsetHeight -  Dom.calc(elem, 'by+py') + 'px';
					case 'width':
						return elem.offsetWidth === 0 ? 'auto': elem.offsetWidth -  Dom.calc(elem, 'bx+px') + 'px';
					case 'opacity':
						return new Dom(elem).getOpacity().toString();
				}
			}
			// currentStyle：IE的样式获取方法,runtimeStyle是获取运行时期的样式。
			// currentStyle是运行时期样式与style属性覆盖之后的样式
			var r = elem.currentStyle;
	
			if(!r)
				return &quot;&quot;;
			r = r[name];
	
			// 来自 jQuery
			// 如果返回值不是一个带px的 数字。 转换为像素单位
			if(/^-?\d/.test(r) &amp;&amp; !/^-?\d+(?:px)?$/i.test(r)) {
	
				// 保存初始值
				var style = elem.style, left = style.left, rsLeft = elem.runtimeStyle.left;
	
				// 放入值来计算
				elem.runtimeStyle.left = elem.currentStyle.left;
				style.left = name === &quot;fontSize&quot; ? &quot;1em&quot;: (r || 0);
				r = style.pixelLeft + &quot;px&quot;;
	
				// 回到初始值
				style.left = left;
				elem.runtimeStyle.left = rsLeft;
	
			}
	
			return r;
		},
		
		/// #else
		
		/// getStyle = function (elem, name) {
		///
		/// 	// 获取样式
		/// 	var computedStyle = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
		///
		/// 	// 返回
		/// 	return computedStyle ? computedStyle[ name ]: null;
		///
		/// },
		/// #endif
		
		/**
		 * 获取滚动大小的方法。
		 * @type Function
		 */
		getScroll = function() {
			var elem = this.dom;
			return new Point(elem.scrollLeft, elem.scrollTop);
		},
		
		/**
		 * 获取窗口滚动大小的方法。
		 * @type Function
		 */
		getWindowScroll = 'pageXOffset' in window ? function() {
			var win = this.defaultView;
			return new Point(win.pageXOffset, win.pageYOffset);
		}: getScroll,
		
		/**
		 * 一个返回 true 的函数。
		 */
		returnTrue = Function.from(true),

		/**
		 * float 属性的名字。
		 * @type String
		 */
		styleFloat = 'cssFloat' in div.style ? 'cssFloat': 'styleFloat',
		
		/**
		 * 浏览器使用的真实的 DOMContentLoaded 事件名字。
		 * @type String
		 */
		domReady,
		
		// IE：styleFloat Other：cssFloat

		t,

		pep;
	
	/// #region Dom
	
	/**
	 * @class Dom
	 */
	extend(Dom, {
		
		<span id="Dom-get">/**
		 * 根据一个 *id* 或原生节点获取一个 {@link Dom} 类的实例。
		 * @param {String/Node/Dom/DomList} id 要获取元素的 id 或用于包装成 Dom 对象的任何元素，如是原生的 DOM 节点、原生的 DOM 节点列表数组或已包装过的 Dom 对象。。
	 	 * @return {Dom} 此函数返回是一个 Dom 类型的变量。通过这个变量可以调用所有文档中介绍的 DOM 操作函数。如果无法找到指定的节点，则返回 null 。此函数可简写为 $。
	 	 * @static
	 	 * @example
	 	 * 找到 id 为 a 的元素。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * &amp;lt;p id=&quot;a&quot;&amp;gt;once&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;
	 	 * &lt;/pre&gt;
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.get(&quot;a&quot;);&lt;/pre&gt;
	 	 * #####结果:
	 	 * &lt;pre&gt;{&amp;lt;p id=&quot;a&quot;&amp;gt;once&amp;lt;/p&amp;gt;}&lt;/pre&gt;
	 	 * 
	 	 * &lt;br&gt;
	 	 * 返回 id 为 a1 的 DOM 对象
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p id=&quot;a1&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p id=&quot;a2&quot;&amp;gt;&amp;lt;/p&amp;gt; &lt;/pre&gt;
	 	 *
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.get(document.getElecmentById('a1')) // 等效于 Dom.get('a1')&lt;/pre&gt;
	 	 * &lt;pre&gt;Dom.get(['a1', 'a2']); // 等效于 Dom.get('a1')&lt;/pre&gt;
	 	 * &lt;pre&gt;Dom.get(Dom.get('a1')); // 等效于 Dom.get('a1')&lt;/pre&gt;
	 	 * 
	 	 * #####结果:
	 	 * &lt;pre&gt;{&amp;lt;p id=&quot;a1&quot;&amp;gt;&amp;lt;/p&amp;gt;}&lt;/pre&gt;
		 */</span>
		get: function(id) {
			
			return typeof id === &quot;string&quot; ?
				(id = document.getElementById(id)) &amp;&amp; new Dom(id) :
				id ? 
					id.nodeType ? 
						new Dom(id) :
						id.dom ? 
							id : 
							Dom.get(id[0]) : 
					null;
			
		},
		
		<span id="Dom-find">/**
		 * 执行一个 CSS 选择器，返回第一个元素对应的 {@link Dom} 对象。
		 * @param {String/NodeList/DomList/Array/Dom} 用来查找的 CSS 选择器或原生的 DOM 节点。
		 * @return {Element} 如果没有对应的节点则返回一个空的 DomList 对象。
	 	 * @static
	 	 * @see DomList
	 	 * @example
	 	 * 找到第一个 p 元素。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####Javascript:
	 	 * &lt;pre&gt;
	 	 * Dom.find(&quot;p&quot;);
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * {  &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt;  }
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * &lt;br&gt;
	 	 * 找到第一个 p 元素，并且这些元素都必须是 div 元素的子元素。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;&lt;/pre&gt;
	 	 * 
	 	 * #####Javascript:
	 	 * &lt;pre&gt;
	 	 * Dom.find(&quot;div &amp;gt; p&quot;);
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * { &amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt; }
	 	 * &lt;/pre&gt;
		 */</span>
		find: function(selector){
			
			return typeof selector === &quot;string&quot; ?
				document.find(selector) :
				Dom.get(selector);
		},
		
		<span id="Dom-query">/**
		 * 执行一个 CSS 选择器，返回一个新的 {@link DomList} 对象。
		 * @param {String/NodeList/DomList/Array/Dom} 用来查找的 CSS 选择器或原生的 DOM 节点列表。
		 * @return {Element} 如果没有对应的节点则返回一个空的 DomList 对象。
	 	 * @static
	 	 * @see DomList
	 	 * @example
	 	 * 找到所有 p 元素。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####Javascript:
	 	 * &lt;pre&gt;
	 	 * Dom.query(&quot;p&quot;);
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * [  &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt; ,&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;, &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;  ]
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * &lt;br&gt;
	 	 * 找到所有 p 元素，并且这些元素都必须是 div 元素的子元素。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * &amp;lt;p&amp;gt;one&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;three&amp;lt;/p&amp;gt;&lt;/pre&gt;
	 	 * 
	 	 * #####Javascript:
	 	 * &lt;pre&gt;
	 	 * Dom.query(&quot;div &amp;gt; p&quot;);
	 	 * &lt;/pre&gt;
	 	 * 
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
	 	 * [ &amp;lt;p&amp;gt;two&amp;lt;/p&amp;gt; ]
	 	 * &lt;/pre&gt;
         * 
	 	 * &lt;br&gt;
         * 查找所有的单选按钮(即: type 值为 radio 的 input 元素)。
         * &lt;pre&gt;Dom.query(&quot;input[type=radio]&quot;);&lt;/pre&gt;
		 */</span>
		query: function(selector) {
			
			// 如果传入的是字符串，作为选择器处理。
			// 否则作为一个节点处理。
			return selector ? 
				typeof selector === 'string' ? 
					document.query(selector) :
					typeof selector.length === 'number' ? 
						selector instanceof DomList ?
							selector :
							new DomList(selector) :
						new DomList([Dom.get(selector)]) :
				new DomList;
			
		},
		
		<span id="Dom-match">/**
		 * 判断一个元素是否符合一个选择器。
		 * @param {Node} elem 一个 HTML 节点。
		 * @param {String} selector 一个 CSS 选择器。
		 * @return {Boolean} 如果指定的元素匹配输入的选择器，则返回 true， 否则返回 false 。
	 	 * @static
		 */</span>
		match: function (elem, selector) {
			assert.isString(selector, &quot;Dom.prototype.find(selector): selector ~。&quot;);
			
			if(elem.nodeType !== 1)
				return false;
				
			if(!elem.parentNode){
				var div = document.createElement('div');
				div.appendChild(elem);
				try{
					return match(elem, selector);
				} finally {
					div.removeChild(elem);
				}
			}
			return match(elem, selector);
		},

		<span id="Dom-parse">/**
		 * 根据提供的原始 HTML 标记字符串，解析并动态创建一个节点，并返回这个节点的 Dom 对象包装对象。
		 * @param {String/Node} html 用于动态创建DOM元素的HTML字符串。
		 * @param {Document} ownerDocument=document 创建DOM元素所在的文档。
		 * @param {Boolean} cachable=true 指示是否缓存节点。
		 * @return {Dom} Dom 对象。
	 	 * @static
	 	 * @remark
	 	 * 可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当创建单个元素时，请使用闭合标签或 XHTML 格式。
	 	 * 在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。
	 	 * 
	 	 * @example
	 	 * 动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.parse(&quot;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&quot;).appendTo(document.body);&lt;/pre&gt;
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;]&lt;/pre&gt;
	 	 * 
	 	 * 创建一个 &amp;lt;input&amp;gt; 元素必须同时设定 type 属性。因为微软规定 &amp;lt;input&amp;gt; 元素的 type 只能写一次。
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;
	 	 * // 在 IE 中无效:
	 	 * Dom.parse(&quot;&amp;lt;input&amp;gt;&quot;).setAttr(&quot;type&quot;, &quot;checkbox&quot;);
	 	 * // 在 IE 中有效:
	 	 * Dom.parse(&quot;&amp;lt;input type='checkbox'&amp;gt;&quot;);
	 	 * &lt;/pre&gt;        
		 */</span>
		parse: function(html, context, cachable) {

			assert.notNull(html, 'Dom.parse(html, context, cachable): {html} ~');

			return html.dom ? html: new Dom(Dom.parseNode(html, context, cachable));
		},
		
		<span id="Dom-create">/**
		 * 创建一个指定标签的节点，并返回这个节点的 Dom 对象包装对象。
		 * @param {String} tagName 要创建的节点标签名。
		 * @param {String} className 用于新节点的 CSS 类名。
	 	 * @static
	 	 * @example
	 	 * 动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.create(&quot;div&quot;, &quot;cls&quot;).appendTo(document.body);&lt;/pre&gt;
	 	 *
	 	 * 创建一个 div 元素同时设定 class 属性。
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.create(&quot;div&quot;, &quot;className&quot;);&lt;/pre&gt;
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;{&amp;lt;div class=&quot;className&quot;&amp;gt;&amp;lt;/div&amp;gt;}&lt;/pre&gt;
		 */</span>
		create: function(tagName, className) {
			return new Dom(Dom.createNode(tagName, className || ''));
		},
		
		<span id="Dom-createNode">/**
		 * 创建一个节点。
		 * @param {String} tagName 创建的节点的标签名。
		 * @param {String} className 创建的节点的类名。
	 	 * @static
		 */</span>
		createNode: function(tagName, className) {
			assert.isString(tagName, 'Dom.create(tagName, className): {tagName} ~');
			var div = document.createElement(tagName);
			div.className = className;
			return div;
		},
		
		<span id="Dom-getNode">/**
		 * 根据一个 id 获取元素。如果传入的id不是字符串，则直接返回参数。
		 * @param {String/Node/Dom} id 要获取元素的 id 或元素本身。
	 	 * @return {Node} 元素。
	 	 * @static
		 */</span>
		getNode: function (id) {
			return typeof id === &quot;string&quot; ?
				document.getElementById(id) :
				id ? 
					id.nodeType ? 
						id :
						id.dom || Dom.getNode(id[0]) : 
					null;
			
		},

		<span id="Dom-parseNode">/**
		 * 解析一个 html 字符串，返回相应的原生节点。
		 * @param {String/Element} html 字符。
		 * @param {Element} context=document 生成节点使用的文档中的任何节点。
		 * @param {Boolean} cachable=true 指示是否缓存节点。
		 * @return {Element/TextNode/DocumentFragment} 元素。
	 	 * @static
		 */</span>
		parseNode: function(html, context, cachable) {

			// 不是 html，直接返回。
			if( typeof html === 'string') {

				var srcHTML = html;

				// 查找是否存在缓存。
				html = cache[srcHTML];
				context = context &amp;&amp; context.ownerDocument || document;

				assert(context.createElement, 'Dom.parseNode(html, context, cachable): {context} 必须是 DOM 节点。', context);

				if(html &amp;&amp; html.ownerDocument === context) {

					// 复制并返回节点的副本。
					html = html.cloneNode(true);

				} else {

					// 测试查找 HTML 标签。
					var tag = /&lt;([\w:]+)/.exec(srcHTML);
					cachable = cachable !== false;

					if(tag) {

						assert.isString(srcHTML, 'Dom.parseNode(html, context, cachable): {html} ~');
						html = context.createElement(&quot;div&quot;);

						var wrap = tagFix[tag[1].toLowerCase()] || tagFix.$default;

						html.innerHTML = wrap[1] + srcHTML.trim().replace(rXhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;) + wrap[2];

						// 转到正确的深度。
						// IE 肯能无法正确完成位置标签的处理。
						for( tag = wrap[0]; tag--; )
						html = html.lastChild;

						// 如果解析包含了多个节点。
						if(html.previousSibling) {
							wrap = html.parentNode;

							assert(context.createDocumentFragment, 'Dom.parseNode(html, context, cachable): {context} 必须是 DOM 节点。', context);
							html = context.createDocumentFragment();
							while(wrap.firstChild) {
								html.appendChild(wrap.firstChild);
							}
						}

						assert(html, &quot;Dom.parseNode(html, context, cachable): 无法根据 {html} 创建节点。&quot;, srcHTML);

						// 一般使用最后的节点， 如果存在最后的节点，使用父节点。
						// 如果有多节点，则复制到片段对象。
						cachable = cachable &amp;&amp; !/&lt;(?:script|object|embed|option|style)/i.test(srcHTML);

					} else {

						// 创建文本节点。
						html = context.createTextNode(srcHTML);
					}

					if(cachable) {
						cache[srcHTML] = html.cloneNode(true);
					}

				}

			}

			return html;

		},
		
		<span id="Dom-hasChild">/**
		 * 判断指定节点之后有无存在子节点。
		 * @param {Element} elem 节点。
		 * @param {Element} child 子节点。
		 * @return {Boolean} 如果确实存在子节点，则返回 true ， 否则返回 false 。
	 	 * @static
		 */</span>
		hasChild: div.compareDocumentPosition ? function(elem, child) {
			assert.isNode(elem, &quot;Dom.hasChild(elem, child): {elem} ~&quot;);
			assert.isNode(child, &quot;Dom.hasChild(elem, child): {child} ~&quot;);
			return !!(elem.compareDocumentPosition(child) &amp; 16);
		}: function(elem, child) {
			assert.isNode(elem, &quot;Dom.hasChild(elem, child): {elem} ~&quot;);
			assert.isNode(child, &quot;Dom.hasChild(elem, child): {child} ~&quot;);
			while( child = child.parentNode)
				if(elem === child)
					return true;

			return false;
		},
		
		<span id="Dom-getText">/**
		 * 获取一个元素对应的文本。
		 * @param {Element} elem 元素。
		 * @return {String} 值。对普通节点返回 text 属性。
	 	 * @static
		 */</span>
		getText: function(elem) {

			assert.isNode(elem, &quot;Dom.getText(elem, name): {elem} ~&quot;);
			return elem[textFix[elem.nodeName] || attrFix.innerText] || '';
		},

		<span id="Dom-getAttr">/**
		 * 获取元素的属性值。
		 * @param {Node} elem 元素。
		 * @param {String} name 要获取的属性名称。
		 * @return {String} 返回属性值。如果元素没有相应属性，则返回 null 。
	 	 * @static
		 */</span>
		getAttr: function(elem, name) {

			assert.isNode(elem, &quot;Dom.getAttr(elem, name): {elem} ~&quot;);

			// if(navigator.isSafari &amp;&amp; name === 'selected' &amp;&amp;
			// elem.parentNode) { elem.parentNode.selectIndex;
			// if(elem.parentNode.parentNode)
			// elem.parentNode.parentNode.selectIndex; }
			var fix = attrFix[name];

			// 如果是特殊属性，直接返回Property。
			if(fix) {

				if(fix.get)
					return fix.get(elem, name);

				assert(!elem[fix] || !elem[fix].nodeType, &quot;Dom.getAttr(elem, name): 表单内不能存在 {name} 的元素。&quot;, name);

				// 如果 这个属性是自定义属性。
				if( fix in elem)
					return elem[fix];
			}

			assert(elem.getAttributeNode, &quot;Dom.getAttr(elem, name): {elem} 不支持 getAttribute。&quot;, elem);

			// 获取属性节点，避免 IE 返回属性。
			fix = elem.getAttributeNode(name);

			// 如果不存在节点， name 为 null ，如果不存在节点值， 返回 null。
			return fix &amp;&amp; (fix.value || null);

		},
		
		<span id="Dom-isHidden">/**
		 * 判断一个节点是否隐藏。
		 * @method isHidden
		 * @return {Boolean} 隐藏返回 true 。
	 	 * @static
		 */</span>
		
		<span id="Dom-hasClass">/**
		 * 检查是否含指定类名。
		 * @param {Element} elem 元素。
		 * @param {String} className 类名。
		 * @return {Boolean} 如果存在返回 true。
	 	 * @static
		 */</span>
		hasClass: function(elem, className) {
			assert.isNode(elem, &quot;Dom.hasClass(elem, className): {elem} ~&quot;);
			assert(className &amp;&amp; (!className.indexOf || !/[\s\r\n]/.test(className)), &quot;Dom.hasClass(elem, className): {className} 不能空，且不允许有空格和换行。&quot;);
			return (&quot; &quot; + elem.className + &quot; &quot;).indexOf(&quot; &quot; + className + &quot; &quot;) &gt;= 0;
		},
			
		dataField: function(elem){
			return Dom.prototype.dataField.call({dom: elem});
		},
		
		<span id="Dom-propFix">/**
		 * 特殊属性集合。
		 * @type Object 特殊的属性，在节点复制时不会被复制，因此需要额外复制这些属性内容。
	 	 * @static
		 */</span>
		propFix: {
			INPUT: 'checked',
			OPTION: 'selected',
			TEXTAREA: 'value'
		},
		
		<span id="Dom-attrFix">/**
		 * 特殊属性集合。
		 * @property
		 * @type Object
		 * @static
		 * @private
		 */</span>
		attrFix: attrFix,
		
		<span id="Dom-textFix">/**
		 * 获取文本时应使用的属性值。
		 * @private
	 	 * @static
		 */</span>
		textFix: textFix,
		
		<span id="Dom-styleFix">/**
		 * 特殊的样式集合。
		 * @property
		 * @type Object
		 * @private
	 	 * @static
		 */</span>
		styleFix: styleFix,
	
		<span id="Dom-pseudos">/**
		 * 用于查找所有支持的伪类的函数集合。
		 * @private
	 	 * @static
		 */</span>
		pseudos: {
			
			target : function (elem) {
				var nameOrId = elem.id || elem.name;
				if(!nameOrId) return false;
				var doc = getDocument(elem).defaultView;
				return nameOrId === (doc.defaultView || doc.parentWindow).location.hash.slice(1)
			},
			
			empty: Dom.isEmpty = function(elem) {
				for( elem = elem.firstChild; elem; elem = elem.nextSibling )
					if( elem.nodeType === 1 || elem.nodeType === 3 ) 
						return false;
				return true;
			},
			
			contains: function( elem, args){ 
				return Dom.getText(elem).indexOf(args) &gt;= 0;
			},
			
			<span id="Dom-pseudos-hidden">/**
			 * 判断一个节点是否隐藏。
			 * @return {Boolean} 隐藏返回 true 。
			 */</span>
			hidden: Dom.isHidden = function(elem) {
				return (elem.style.display || getStyle(elem, 'display')) === 'none';
			},
			visible: function( elem ){ return !Dom.isHidden(elem); },
			
			not: function(elem, args){ return !match(elem, args); },
			has: function(elem, args){ return query(args, new Dom(elem)).length &gt; 0; },
			
			selected: function(elem){ return elem.selected; },
			checked: function(elem){ return elem.checked; },
			enabled: function(elem){ return elem.disabled === false; },
			disabled: function(elem){ return elem.disabled === true; },
			
			input: function(elem){ return /^(input|select|textarea|button)$/i.test(elem.nodeName); },
			
			&quot;nth-child&quot;: function(args, oldResult, result){
				var System = Dom.pseudos;
				if(System[args]){
					System[args](null, oldResult, result);	
				} else if(args = oldResult[args - 1])
					result.push(args);
			},
			&quot;first-child&quot;: function (args, oldResult, result) {
				if(args = oldResult[0])
					result.push(args);
			},
			&quot;last-child&quot;: function (args, oldResult, result) {
				if(args = oldResult[oldResult.length - 1])
					result.push(args);
			},
			&quot;only-child&quot;: function(elem){ 
				var p = new Dom(elem.parentNode).first(elem.nodeName);
				return p &amp;&amp; p.next(); 
			},
			odd: function(args, oldResult, result){
				var index = 0, elem, t;
				while(elem = oldResult[index++]) {
					if(args){
						result.push(elem);	
					}
				}
			},
			even: function(args, oldResult, result){
				return Dom.pseudos.odd(!args, oldResult, result);
			}
			
		},

		<span id="Dom-displayFix">/**
		 * 显示元素的样式。
		 * @static
		 * @type Object
		 */</span>
		displayFix: {
			position: &quot;absolute&quot;,
			visibility: &quot;visible&quot;,
			display: &quot;block&quot;
		},
		
		<span id="Dom-styleNumbers">/**
		 * 不需要单位的 css 属性。
		 * @static
		 * @type Object
		 */</span>
		styleNumbers: map('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', returnTrue, {}),

		<span id="Dom-zIndex">/**
		 * 默认最大的 z-index 。
		 * @property zIndex
		 * @type Number
		 * @private
		 * @static
		 */</span>
		
		<span id="Dom-window">/**
		 * 
	 	 * @static
		 */</span>
		window: new Dom(window),
		
		<span id="Dom-document">/**
		 * 
	 	 * @static
		 */</span>
		document: new Dom(document),

		<span id="Dom-getStyle">/**
		 * 获取元素的计算样式。
		 * @param {Element} dom 节点。
		 * @param {String} name 名字。
		 * @return {String} 样式。
	 	 * @static
	 	 *  访问元素的样式属性。
        &lt;params name=&quot;name&quot; type=&quot;String&quot;&gt;
          要访问的属性名称
        &lt;/params&gt;
        @example
          取得第一个段落的color样式属性的值。
          #####JavaScript:&lt;pre&gt;Dom.query(&quot;p&quot;).getStyle(&quot;color&quot;);&lt;/pre&gt;
        
		 */</span>
		getStyle: getStyle,

		<span id="Dom-styleString">/**
		 * 读取样式字符串。
		 * @param {Element} elem 元素。
		 * @param {String} name 属性名。必须使用骆驼规则的名字。
		 * @return {String} 字符串。
	 	 * @static
		 */</span>
		styleString: styleString,

		<span id="Dom-styleNumber">/**
		 * 读取样式数字。
		 * @param {Element} elem 元素。
		 * @param {String} name 属性名。必须使用骆驼规则的名字。
		 * @return {String} 字符串。
		 * @static
		 */</span>
		styleNumber: styleNumber,

		initToggleArgs: function (args) {
			if(typeof args[0] === 'string')
				return args;
			ap.unshift.call(args, 'opacity');
			return args;
		},

		<span id="Dom-show">/**
		 * 清空元素的 display 属性。
		 * @param {Element} elem 元素。
	 	 * @static
		 */</span>
		show: function(elem) {
			assert.isElement(elem, &quot;Dom.show(elem): {elem} ~&quot;);

			// 普通元素 设置为 空， 因为我们不知道这个元素本来的 display 是 inline 还是 block
			elem.style.display = '';

			// 如果元素的 display 仍然为 none , 说明通过 CSS 实现的隐藏。这里默认将元素恢复为 block。
			if(getStyle(elem, 'display') === 'none')
				elem.style.display = elem.style.$display || 'block';
		},
		
		<span id="Dom-hide">/**
		 * 赋予元素的 display 属性 none。
		 * @param {Element} elem 元素。
	 	 * @static
		 */</span>
		hide: function(elem) {
			assert.isElement(elem, &quot;Dom.hide(elem): {elem} ~&quot;);
			var currentDisplay = styleString(elem, 'display');
			if(currentDisplay !== 'none') {
				elem.style.$display = currentDisplay;
				elem.style.display = 'none';
			}
		},
		
		<span id="Dom-calc">/**
		 * 根据不同的内容进行计算。
		 * @param {Element} elem 元素。
		 * @param {String} type 输入。 一个 type
		 *            由多个句子用,连接，一个句子由多个词语用+连接，一个词语由两个字组成， 第一个字可以是下列字符之一:
		 *            m b System t l r b h w 第二个字可以是下列字符之一: x y l t b r
		 *            b。词语也可以是: outer inner 。
		 * @return {Number} 计算值。 mx+sx -&gt; 外大小。 mx-sx -&gt; 内大小。
	 	 * @static
		 */</span>
		calc: (function() {

			var borders = {
				m: 'margin#',
				b: 'border#Width',
				p: 'padding#'
			}, map = {
				t: 'Top',
				r: 'Right',
				b: 'Bottom',
				l: 'Left'
			}, init, tpl;

			if(window.getComputedStyle) {
				init = 'var c=e.ownerDocument.defaultView.getComputedStyle(e,null);return ';
				tpl = '(parseFloat(c[&quot;#&quot;]) || 0)';
			} else {
				init = 'return ';
				tpl = '(parseFloat(Dom.getStyle(e, &quot;#&quot;)) || 0)';
			}

			/**
			 * 翻译 type。
			 * @param {String} type 输入字符串。
			 * @return {String} 处理后的字符串。
			 */
			function format(type) {
				var t, f = type.charAt(0);
				switch (type.length) {

					case 2:
						t = type.charAt(1);
						assert( f in borders || f === 's', &quot;Dom.calc(e, type): {type} 中的 &quot; + type + &quot; 不合法&quot;, type);
						if( t in map) {
							t = borders[f].replace('#', map[t]);
						} else {
							return f === 's' ? 'e.offset' + (t === 'x' ? 'Width': 'Height'): '(' + format(f + (t !== 'y' ? 'l': 't')) + '+' + format(f + (t === 'x' ? 'r': 'b')) + ')';
						}

						break;

					case 1:
						if( f in map) {
							t = map[f].toLowerCase();
						} else if(f !== 'x' &amp;&amp; f !== 'y') {
							assert(f === 'h' || f === 'w', &quot;Dom.calc(e, type): {type} 中的 &quot; + type + &quot; 不合法&quot;, type);
							return 'Dom.styleNumber(e,&quot;' + (f === 'h' ? 'height': 'width') + '&quot;)';
						} else {
							return f;
						}

						break;

					default:
						t = type;
				}

				return tpl.replace('#', t);
			}

			return function(elem, type) {
				assert.isElement(elem, &quot;Dom.calc(elem, type): {elem} ~&quot;);
				assert.isString(type, &quot;Dom.calc(elem, type): {type} ~&quot;);
				return (sizeMap[type] || (sizeMap[type] = new Function(&quot;e&quot;, init + type.replace(/\w+/g, format))))(elem);
			}
		})(),

		<span id="Dom-movable">/**
		 * 设置一个元素可拖动。
		 * @param {Element} elem 要设置的节点。
	 	 * @static
		 */</span>
		movable: function(elem) {
			assert.isElement(elem, &quot;Dom.movable(elem): 参数 elem ~&quot;);
			if(!/^(?:abs|fix)/.test(styleString(elem, &quot;position&quot;)))
				elem.style.position = &quot;relative&quot;;
		},
		
		<span id="Dom-getDocument">/**
		 * 获取元素的文档。
		 * @param {Element} elem 元素。
		 * @return {Document} 文档。
	 	 * @static
		 */</span>
		getDocument: getDocument,
	
		<span id="Dom-implement">/**
		 * 将一个成员附加到 Dom 对象和相关类。
		 * @param {Object} obj 要附加的对象。
		 * @param {Number} listType = 1 说明如何复制到 DomList 实例。
		 * @return this
		 * @static
		 * 对 Element 扩展，内部对 Element DomList document 皆扩展。
		 *         这是由于不同的函数需用不同的方法扩展，必须指明扩展类型。 所谓的扩展，即一个类所需要的函数。 DOM 方法
		 *         有 以下种 1, 其它 setText - 执行结果返回 this， 返回 this 。(默认) 2
		 *         getText - 执行结果是数据，返回结果数组。 3 getElementById - 执行结果是DOM
		 *         或 ElementList，返回 DomList 包装。 4 hasClass -
		 *         只要有一个返回等于 true 的值， 就返回这个值。 参数 copyIf 仅内部使用。
		 */</span>
		implement: function(members, listType, copyIf) {
			assert.notNull(members, &quot;Dom.implement&quot; + ( copyIf ? 'If' : '') + &quot;(members, listType): {members} ~&quot;);
		
			Object.each(members, function(value, func) {
		
				var i = this.length;
				while(i--) {
					var cls = this[i].prototype;
					if(!copyIf || !cls[func]) {
		
						if(!i) {
							switch (listType) {
								case 2:
									// return array
									value = function() {
										return this.invoke(func, arguments);
									};
									break;
		
								case 3:
									// return DomList
									value = function() {
										var r = new DomList;
										return r.concat.apply(r, this.invoke(func, arguments));
									};
									break;
								case 4:
									// return if true
									value = function() {
										var i = -1, item = null, target = new Dom();
										while(++i &lt; this.length &amp;&amp; !item) {
											target.dom = this[i];
											item = target[func].apply(target, arguments);
										}
										return item;
									};
									break;
								default:
									// return this
									value = function() {
										var len = this.length, i = -1, target;
										while(++i &lt; len) {
											target = new Dom(this[i]);
											target[func].apply(target, arguments);
										}
										return this;
									};
							}
						}
		
						cls[func] = value;
					}
				}
		
			}, [DomList, Dom.Document, Dom]);
		
			return this;

		},
	
		<span id="Dom-implementIf">/**
		 * 若不存在，则将一个对象附加到 Element 对象。
		 * @static
		 * @param {Object} obj 要附加的对象。
		 * @param {Number} listType = 1 说明如何复制到 DomList 实例。
		 * @param {Number} docType 说明如何复制到 Document 实例。
		 * @return this
		 */</span>
		implementIf: function(obj, listType) {
			return this.implement(obj, listType, true);
		},
	
		<span id="Dom-define">/**
		 * 将指定名字的方法委托到当前对象指定的成员。
		 * @param {Object} Dom 类。
		 * @param {String} delegate 委托变量。
		 * @param {String} methods 所有成员名。
		 *            因此经常需要将一个函数转换为对节点的调用。
		 * @static
		 */</span>
		define: function(ctrl, target, setters, getters) {
			assert(ctrl &amp;&amp; ctrl.prototype, &quot;Dom.define(ctrl, target, setters, getters): {ctrl} 必须是一个类&quot;, ctrl);
			
			if(typeof getters === 'string'){
				Dom.define(ctrl, target, getters, true);
				getters = 0;
			}
			
			map(setters, function(func) {
				ctrl.prototype[func] = getters ? function(args1, args2) {
					return this[target][func](args1, args2);
				} : function(args1, args2) {
					this[target][func](args1, args2);
					return this;
				};
			});
			return Dom.define;
		},

		<span id="Dom-Event">/**
		 * 表示事件的参数。
		 * @class Dom.Event
		 */</span>
		Event: Class({

			<span id="Dom-Event-prototype-constructor">/**
			 * 构造函数。
			 * @param {Object} target 事件对象的目标。
			 * @param {String} type 事件对象的类型。
			 * @param {Object} [e] 事件对象的属性。
			 * @constructor
			 */</span>
			constructor: function(target, type, e) {
				assert.notNull(target, &quot;Dom.Event.prototype.constructor(target, type, e): {target} ~&quot;);

				var me = this;
				me.target = target;
				me.type = type;
				extend(me, e);
			},
			
			<span id="Dom-Event-prototype-stopPropagation">/**
			 * 阻止事件的冒泡。
			 * @remark 默认情况下，事件会向父元素冒泡。使用此函数阻止事件冒泡。
			 */</span>
			stopPropagation: function() {
				this.cancelBubble = true;
			},
			
			<span id="Dom-Event-prototype-preventDefault">/**
			 * 取消默认事件发生。
			 * @remark 有些事件会有默认行为，如点击链接之后执行跳转，使用此函数阻止这些默认行为。
			 */</span>
			preventDefault: function() {
				this.returnValue = false;
			},
			
			<span id="Dom-Event-prototype-stop">/**
			 * 停止默认事件和冒泡。
			 * @remark 此函数可以完全撤销事件。 事件处理函数中 return false 和调用 stop() 是不同的， return
			 *         false 只会阻止当前事件其它函数执行， 而 stop() 只阻止事件冒泡和默认事件，不阻止当前事件其它函数。
			 */</span>
			stop: function() {
				this.stopPropagation();
				this.preventDefault();
			},
			
			<span id="Dom-Event-prototype-getTarget">/**
			 * 获取当前发生事件 Dom 对象。
			 * @return {Dom} 发生事件 Dom 对象。
			 */</span>
			getTarget: function() {
				assert(this.target, &quot;Dom.Event.prototype.getTarget(): 当前事件不支持 getTarget 操作&quot;);
				return new Dom(this.target.nodeType === 3 ? this.target.parentNode: this.target);
			}
		}),

		<span id="Dom-Document">/**
		 * 文档对象。
		 * @constructor Dom.Document 
		 * @extends Dom
		 * @remark 因为 IE6/7 不存在这些对象, 文档对象是对原生 HTMLDocument 对象的补充。 扩展
		 *        Document 也会扩展 HTMLDocument。
		 */</span>
		Document: System.Native(document.constructor || {
			prototype: document
		})

	})
	
	/**@class Dom*/
	
	.implement({
	
		<span id="Dom-prototype-appendTo">/**
		 * 将当前 Dom 对象添加到其它节点或 Dom 对象中。
		 * @param {Node/String} parent=document.body 节点 Dom 对象或节点的 id 字符串。
		 * @return this
		 * @remark
		 * this.appendTo(parent) 相当于 parent.append(this) 。 
		 * @example
		 * 把所有段落追加到ID值为foo的元素中。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;p&amp;gt;I would like to say: &amp;lt;/p&amp;gt;&amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).appendTo(&quot;foo&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;p&amp;gt;I would like to say: &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 * 
		 * 创建一个新的div节点并添加到 document.body 中。
		 * &lt;pre&gt;
		 * Dom.create(&quot;div&quot;).appendTo();
		 * &lt;/pre&gt;
		 */</span>
		appendTo: function(parent) {
		
			// parent 肯能为 true
			parent &amp;&amp; parent !== true ? (parent.append ? parent : Dom.get(parent)).append(this) : this.attach(document.body, null);

			return this;
	
		},
	
		<span id="Dom-prototype-remove">/**
		 * 移除当前 Dom 对象或其子对象。
		 * @param {Dom} [child] 如果指定了子对象，则删除此对象。
		 * @return this
		 * @see #dispose
		 * @remark
		 * 这个方法不会彻底移除 Dom 对象，而只是暂时将其从 Dom 树分离。
		 * 如果需要彻底删除 Dom 对象，使用 {@link #dispose}方法。
		 * @example
		 * 从DOM中把所有段落删除。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; how are &amp;lt;p&amp;gt;you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).remove();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;how are&lt;/pre&gt;
		 * 
		 * 从DOM中把带有hello类的段落删除
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p class=&quot;hello&quot;&amp;gt;Hello&amp;lt;/p&amp;gt; how are &amp;lt;p&amp;gt;you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).remove(&quot;.hello&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;how are &amp;lt;p&amp;gt;you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		remove: function(child) {
	
			if (arguments.length) {
				assert(child &amp;&amp; this.hasChild(child), 'Dom.prototype.remove(child): {child} 不是当前节点的子节点', child);
				this.removeChild(child);
			} else if (child = this.parentControl || this.parent()){
				child.removeChild(this);
			}
	
			return this;
		},
	
		<span id="Dom-prototype-empty">/**
	 	 * 删除一个节点的所有子节点。
		 * @return this
		 * @example
		 * 把所有段落的子元素（包括文本节点）删除。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello, &amp;lt;span&amp;gt;Person&amp;lt;/span&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;and person&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).empty();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		empty: function() {
			var elem = this.dom;
			if(elem.nodeType == 1)
				Object.each(elem.getElementsByTagName(&quot;*&quot;), clean);
			while (elem = this.last(true))
				this.removeChild(elem);
			return this;
		},
	
		<span id="Dom-prototype-dispose">/**
		 * 彻底删除当前 DOM 对象。释放占用的所有资源。
		 * @see #remove
		 * @remark 这个方法会同时删除节点绑定的事件以及所有的数据。
		 * @example
		 * 从DOM中把所有段落删除。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;dispose&amp;lt;/p&amp;gt; how are &amp;lt;p&amp;gt;you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).dispose();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;how are&lt;/pre&gt;
		 * 
		 * 从DOM中把带有hello类的段落删除。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p class=&quot;hello&quot;&amp;gt;Hello&amp;lt;/p&amp;gt; how are &amp;lt;p&amp;gt;you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).dispose(&quot;.hello&quot;);&lt;/pre&gt;
		 */</span>
		dispose: function() {
			if(this.dom.nodeType == 1){
				Object.each(this.dom.getElementsByTagName(&quot;*&quot;), clean)
				clean(this.dom);
			}
			
			this.remove();
		},
	
		<span id="Dom-prototype-setStyle">/**
		 * 设置一个样式属性的值。
		 * @param {String} name CSS 属性名或 CSS 字符串。
		 * @param {String/Number} [value] CSS属性值， 数字如果不加单位，则会自动添加像素单位。
		 * @return this
		 * @example
		 * 将所有段落的字体颜色设为红色并且背景为蓝色。
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).setStyle('color', &quot;#ff0011&quot;);&lt;/pre&gt;
		 */</span>
		setStyle: function(name, value) {
		
			// 获取样式
			var me = this;
			
			assert.isString(name, &quot;Dom.prototype.setStyle(name, value): {name} ~&quot;);
			assert.isElement(me.dom, &quot;Dom.prototype.setStyle(name, value): 当前 dom 不支持样式&quot;);
		
			// 设置通用的属性。
			if(arguments.length == 1){
				me.dom.style.cssText += ';' + name;
				
			// 特殊的属性值。
			} else if( name in styleFix) {
		
				// setHeight setWidth setOpacity
				return me[styleFix[name]](value);
		
			} else {
				name = name.replace(rStyle, formatStyle);
		
				assert(value || !isNaN(value), &quot;Dom.prototype.setStyle(name, value): {value} 不是正确的属性值。&quot;, value);
		
				// 如果值是函数，运行。
				if( typeof value === &quot;number&quot; &amp;&amp; !( name in Dom.styleNumbers))
					value += &quot;px&quot;;
		
			}
		
			// 指定值。
			me.dom.style[name] = value;
		
			return me;

		},
	
		<span id="Dom-prototype-setOpacity">/**
		 * 设置当前 Dom 对象的透明度。
		 * @param {Number} value 要设置的透明度， 0 表示完全透明，  1 表示不透明。
		 * @return this
		 * @remark 此函数等效于 setStyle('opacity', value);
		 */</span>
		setOpacity: 'opacity' in div.style ? function(value) {
		
			assert(value &lt;= 1 &amp;&amp; value &gt;= 0, 'Dom.prototype.setOpacity(value): {value} 必须在 0~1 间。', value);
			assert.isElement(this.dom, &quot;Dom.prototype.setStyle(name, value): 当前 dom 不支持样式&quot;);
		
			// 标准浏览器使用 opacity
			this.dom.style.opacity = value;
			return this;
		
		}: function(value) {
			var elem = this.dom, style = elem.style;
		
			assert(!+value || (value &lt;= 1 &amp;&amp; value &gt;= 0), 'Dom.prototype.setOpacity(value): {value} 必须在 0~1 间。', value);
			assert.isElement(elem, &quot;Dom.prototype.setStyle(name, value): 当前 dom 不支持样式&quot;);
		
			if(value)
				value *= 100;
			value = value || value === 0 ? 'opacity=' + value : '';
		
			// 获取真实的滤镜。
			elem = styleString(elem, 'filter');
		
			assert(!/alpha\([^)]*\)/i.test(elem) || rOpacity.test(elem), 'Dom.prototype.setOpacity(value): 当前元素的 {filter} CSS属性存在不属于 alpha 的 opacity， 将导致 setOpacity 不能正常工作。', elem);
		
			// 当元素未布局，IE会设置失败，强制使生效。
			style.zoom = 1;
		
			// 设置值。
			style.filter = rOpacity.test(elem) ? elem.replace(rOpacity, value) : (elem + ' alpha(' + value + ')');
		
			return this;

		},
	
		/// #else
		
		/// setOpacity: function (value) {
		///
		/// 	assert(value &lt;= 1 &amp;&amp; value &gt;= 0,
		//   'Dom.prototype.setOpacity(value): {value} 必须在 0~1 间。',
		//    value);
		///
		/// 	// 标准浏览器使用 opacity
		/// 	(this.dom).style.opacity = value;
		/// 	return this;
		///
		/// },
		
		/// #endif
		
		<span id="Dom-prototype-show">/**
		 * 向用户显示当前 Dom 对象。
		 * @param {String} [type] 显示时使用的特效方式。
		 * @param {Number} duration=300 效果执行时间。
		 * @param {Function} [callBack] 效果执行完的回调函数。
		 * @param {String} [link] 当效果正在执行时的处理方式。
		 * 
		 * - &quot;**wait**&quot;(默认): 等待上个效果执行完成。
		 * - &quot;**ignore**&quot;: 忽略新的效果。
		 * - &quot;**stop**&quot;: 正常中止上一个效果，然后执行新的效果。
		 * - &quot;**abort**&quot;: 强制中止上一个效果，然后执行新的效果。
		 * @return this
		 * @remark 此函数是通过设置 css的 display 属性实现的。
		 */</span>
		show: function () {
			var args = Dom.initToggleArgs(arguments);
			Dom.show(this.dom);
			if (args = args[2]) setTimeout(args, 0);
			return this;
		},
	
		<span id="Dom-prototype-hide">/**
		 * 向用户隐藏当前 Dom 对象。
		 * @param {String} [type] 显示时使用的特效方式。
		 * @param {Number} duration=300 效果执行时间。
		 * @param {Function} [callBack] 效果执行完的回调函数。
		 * @param {String} [link] 当效果正在执行时的处理方式。
		 * 
		 * - &quot;**wait**&quot;(默认): 等待上个效果执行完成。
		 * - &quot;**ignore**&quot;: 忽略新的效果。
		 * - &quot;**stop**&quot;: 正常中止上一个效果，然后执行新的效果。
		 * - &quot;**abort**&quot;: 强制中止上一个效果，然后执行新的效果。
		 * @return this
		 * @remark 此函数是通过设置 css的 display = none 实现的。
		 */</span>
		hide: function (duration, callback) {
			var args = Dom.initToggleArgs(arguments);
			Dom.hide(this.dom);
			if (args = args[2]) setTimeout(args, 0);
			return this;
		},
	
		<span id="Dom-prototype-toggle">/**
		 * 切换当前 Dom 对象的显示状态。
		 * @param {String} [type] 显示时使用的特效方式。
		 * @param {Number} duration=300 效果执行时间。
		 * @param {Function} [callBack] 效果执行完的回调函数。
		 * @param {String} [link] 当效果正在执行时的处理方式。
		 * 
		 * - &quot;**wait**&quot;(默认): 等待上个效果执行完成。
		 * - &quot;**ignore**&quot;: 忽略新的效果。
		 * - &quot;**stop**&quot;: 正常中止上一个效果，然后执行新的效果。
		 * - &quot;**abort**&quot;: 强制中止上一个效果，然后执行新的效果。
		 * @return this
		 * @remark 此函数是通过设置 css的 display 属性实现的。
		 */</span>
		toggle: function () {
			var args = Dom.initToggleArgs(arguments);
			return this[(args[4] === undefined ? Dom.isHidden(this.dom) : args[4]) ? 'show' : 'hide'].apply(this, args);
		},
	
		<span id="Dom-prototype-unselectable">/**
		 * 设置当前 Dom 对象不可选。
		 * @param {Boolean} value=true 如果为 true，表示不可选，否则表示可选。
		 * @return this
		 */</span>
		unselectable: 'unselectable' in div ? function(value) {
			assert.isElement(this.dom, &quot;Dom.prototype.unselectable(value): 当前 dom 不支持此操作&quot;);
			this.dom.unselectable = value !== false ? 'on': '';
			return this;
		}: 'onselectstart' in div ? function(value) {
			assert.isElement(this.dom, &quot;Dom.prototype.unselectable(value): 当前 dom 不支持此操作&quot;);
			this.dom.onselectstart = value !== false ? Function.from(false): null;
			return this;
		}: function(value) {
			assert.isElement(this.dom, &quot;Dom.prototype.unselectable(value): 当前 dom 不支持此操作&quot;);
			this.dom.style.MozUserSelect = value !== false ? 'none': '';
			return this;
		},
	
		<span id="Dom-prototype-bringToFront">/**
		 * 将当前 Dom 对象置于指定 Dom 对象的上层。
		 * @param {Dom} [target] 如果指定了参 Dom 对象， Dom 对象将位于指定 Dom 对象之上。
		 * @return this
		 * @remark 此函数是通过设置 css的 z-index 属性实现的。
		 */</span>
		bringToFront: function(target) {
			assert(!target || (target.dom &amp;&amp; target.dom.style), &quot;Dom.prototype.bringToFront(elem): {elem} 必须为 空或允许使用样式 Dom 对象。&quot;, target);
		
			var elem = this.dom, 
				targetZIndex = targetControl&amp;&amp; (parseInt(styleString(target.dom, 'zIndex')) + 1) || (Dom.zIndex ? Dom.zIndex++ : (Dom.zIndex = 10000));
		
			// 如果当前元素的 z-index 未超过目标值，则设置
			if(!(styleString(elem, 'zIndex') &gt; targetZIndex))
				elem.style.zIndex = targetZIndex;
		
			return this;

		}, 
		
		<span id="Dom-prototype-setAttr">/**
		 * 设置或删除一个属性值。
		 * @param {String} name 要设置的属性名称。
		 * @param {String} value 要设置的属性值。当设置为 null 时，删除此属性。
		 * @return this
		 * @example
		 * 为所有图像设置src属性。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;img/&amp;gt;
		 * &amp;lt;img/&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;img&quot;).setAttr(&quot;src&quot;,&quot;test.jpg&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;img src= &quot;test.jpg&quot; /&amp;gt; , &amp;lt;img src= &quot;test.jpg&quot; /&amp;gt; ]&lt;/pre&gt;
		 * 
		 * 将文档中图像的src属性删除
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;img src=&quot;test.jpg&quot;/&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;img&quot;).setAttr(&quot;src&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;img /&amp;gt; ]&lt;/pre&gt;
		 */</span>
		setAttr: function(name, value) {
			var elem = this.dom;
		
			/// #if CompactMode
			
			assert(name !== 'type' || elem.tagName !== &quot;INPUT&quot; || !elem.parentNode, &quot;Dom.prototype.setAttr(name, type): 无法修改INPUT元素的 type 属性。&quot;);
		
			/// #endif
			// 如果是节点具有的属性。
			if( name in attrFix) {
		
				if(attrFix[name].set)
					attrFix[name].set(elem, name, value);
				else {
		
					assert(elem.tagName !== 'FORM' || name !== 'className' || typeof elem.className === 'string', &quot;Dom.prototype.setAttr(name, type): 表单内不能存在 name='className' 的节点。&quot;);
		
					elem[attrFix[name]] = value;
		
				}
		
			} else if(value === null) {
		
				assert(elem.removeAttributeNode, &quot;Dom.prototype.setAttr(name, type): 当前元素不存在 removeAttributeNode 方法&quot;);
		
				if( value = elem.getAttributeNode(name)) {
					value.nodeValue = '';
					elem.removeAttributeNode(value);
				}
		
			} else {
		
				assert(elem.getAttributeNode, &quot;Dom.prototype.setAttr(name, type): 当前元素不存在 getAttributeNode 方法&quot;);
		
				var node = elem.getAttributeNode(name);
		
				if(node)
					node.nodeValue = value;
				else
					elem.setAttribute(name, value);
		
			}
		
			return this;

		},
	
		<span id="Dom-prototype-set">/**
		 * 快速设置当前 Dom 对象的样式、属性或事件。
		 * @param {String/Object} name 属性名。可以是一个 css 属性名或 html 属性名。如果属性名是on开头的，则被认为是绑定事件。 - 或 - 属性值，表示 属性名/属性值 的 JSON 对象。
		 * @param {Object} [value] 属性值。
		 * @return this
		 * @remark
		 * 此函数相当于调用 setStyle 或 setAttr 。数字将自动转化为像素值。
		 * @example
		 * 将所有段落字体设为红色、设置 class 属性、绑定 click 事件。
		 * &lt;pre&gt;
		 * Dom.query(&quot;p&quot;).set(&quot;color&quot;,&quot;red&quot;).set(&quot;class&quot;,&quot;cls-red&quot;).set(&quot;onclick&quot;, function(){alert('clicked')});
		 * &lt;/pre&gt;
		 * 
		 * - 或 -
		 *
		 * &lt;pre&gt;
		 * Dom.query(&quot;p&quot;).set({
		 * 		&quot;color&quot;:&quot;red&quot;,
		 * 		&quot;class&quot;:&quot;cls-red&quot;,
		 * 		&quot;onclick&quot;: function(){alert('clicked')}
		 * });
		 * &lt;/pre&gt;
		 */</span>
		set: function(name, value) {
			var me = this;
		
			if( typeof name === &quot;string&quot;) {
		
				var elem = me.dom;
		
				// event 。
				if(name.match(/^on(\w+)/))
					me.on(RegExp.$1, value);
		
				// css 。
				else if(elem.style &amp;&amp; ( name in elem.style || rStyle.test(name)))
					me.setStyle(name, value);
		
				// attr 。
				else
					me.setAttr(name, value);
		
			} else if(Object.isObject(name)) {
		
				for(value in name)
					me.set(value, name[value]);
		
			}
		
			return me;

		},
	
		<span id="Dom-prototype-addClass">/**
		 * 为当前 Dom 对象添加指定的 Css 类名。
		 * @param {String} className 一个或多个要添加到元素中的CSS类名，用空格分开。
		 * @return this
		 * @example
		 * 为匹配的元素加上 'selected' 类。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).addClass(&quot;selected&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p class=&quot;selected&quot;&amp;gt;Hello&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 *
		 * 为匹配的元素加上 selected highlight 类。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).addClass(&quot;selected highlight&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p class=&quot;selected highlight&quot;&amp;gt;Hello&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		addClass: function(className) {
			assert.isString(className, &quot;Dom.prototype.addClass(className): {className} ~&quot;);
		
			var elem = this.dom, classList = className.split(/\s+/), newClass, i;
		
			if(!elem.className &amp;&amp; classList.length &lt;= 1) {
				elem.className = className;
		
			} else {
				newClass = &quot; &quot; + elem.className + &quot; &quot;;
		
				for( i = 0; i &lt; classList.length; i++) {
					if(newClass.indexOf(&quot; &quot; + classList[i] + &quot; &quot;) &lt; 0) {
						newClass += classList[i] + &quot; &quot;;
					}
				}
				elem.className = newClass.trim();
			}
		
			return this;

		},
	
		<span id="Dom-prototype-removeClass">/**
		 * 从当前 Dom 对象中删除全部或者指定的类。
		 * @param {String} [className] 一个或多个要删除的CSS类名，用空格分开。如果不提供此参数，将清空 className 。
		 * @return this
		 * @example
		 * 从匹配的元素中删除 'selected' 类
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;p class=&quot;selected first&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).removeClass(&quot;selected&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * [ &amp;lt;p class=&quot;first&quot;&amp;gt;Hello&amp;lt;/p&amp;gt; ]
		 * &lt;/pre&gt;
		 */</span>
		removeClass: function(className) {
			assert(!className || className.split, &quot;Dom.prototype.removeClass(className): {className} ~&quot;);
		
			var elem = this.dom, classList, newClass = &quot;&quot;, i;
		
			if(className) {
				classList = className.split(/\s+/);
				newClass = &quot; &quot; + elem.className + &quot; &quot;;
				for( i = classList.length; i--; ) {
					newClass = newClass.replace(&quot; &quot; + classList[i] + &quot; &quot;, &quot; &quot;);
				}
				newClass = newClass.trim();
		
			}
		
			elem.className = newClass;
		
			return this;

		},
	
		<span id="Dom-prototype-toggleClass">/**
		 * 如果存在（不存在）就删除（添加）一个类。
		 * @param {String} className CSS类名。
		 * @param {Boolean} [toggle] 自定义切换的方式。如果为 true， 则加上类名，否则删除。
		 * @return this
		 * @see #addClass
		 * @see #removeClass
		 * @example
		 * 为匹配的元素切换 'selected' 类
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p class=&quot;selected&quot;&amp;gt;Hello Again&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).toggleClass(&quot;selected&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p class=&quot;selected&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;, &amp;lt;p&amp;gt;Hello Again&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		toggleClass: function(className, stateVal) {
			return (stateVal !== undefined ? !stateVal: this.hasClass(className)) ? this.removeClass(className): this.addClass(className);
		},
	
		<span id="Dom-prototype-setText">/**
		 * 设置当前 Dom 对象的文本内容。对于输入框则设置其输入的值。
		 * @param {String} 用于设置元素内容的文本。
		 * @return this
		 * @see #setHtml
		 * @remark 与 {@link #setHtml} 类似, 但将编码 HTML (将 &quot;&amp;lt;&quot; 和 &quot;&amp;gt;&quot; 替换成相应的HTML实体)。
		 * @example
		 * 设定文本框的值。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;input type=&quot;text&quot;/&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;input&quot;).setText(&quot;hello world!&quot;);&lt;/pre&gt;
		 */</span>
		setText: function(value) {
			var elem = this.dom;
			elem[textFix[elem.nodeName] || attrFix.innerText] = value;
			return this;
		},
	
		<span id="Dom-prototype-setHtml">/**
		 * 设置当前 Dom 对象的 Html 内容。
		 * @param {String} value 用于设定HTML内容的值。
		 * @return this
		 * @example
		 * 设置一个节点的内部 html 
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;div id=&quot;a&quot;&amp;gt;&amp;lt;p/&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.get(&quot;a&quot;).setHtml(&quot;&amp;lt;a/&amp;gt;&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;div id=&quot;a&quot;&amp;gt;&amp;lt;a/&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
		 */</span>
		setHtml: function(value) {
			var elem = this.dom,
				map = tagFix.$default;
			
			assert(elem.nodeType === 1, &quot;Dom.prototype.setHtml(value): 仅当 dom.nodeType === 1 时才能使用此函数。&quot;); 
			
			value = (map[1] + value + map[2]).replace(rXhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;);
			// Object.each(elem.getElementsByTagName(&quot;*&quot;), function(node){
			// 	node.$data = null;
			// });
			
			try {
				elem.innerHTML = value;
				
			// 如果 innerHTML 出现错误，则直接使用节点方式操作。
			} catch(e){
				this.empty().append(value);
				return this;
			}
			if (map[0] &gt; 1) {
				value = elem.lastChild;
				elem.removeChild(elem.firstChild);
				elem.removeChild(value);
				while (value.firstChild)
					elem.appendChild(value.firstChild);
			}
	
			return this;
		},

		<span id="Dom-prototype-setSize">/**
		 * 设置当前 Dom 对象的显示大小。
		 * @param {Number/Point} x 要设置的宽或一个包含 x、y 属性的对象。如果不设置，使用 null 。
		 * @param {Number} y 要设置的高。如果不设置，使用 null 。
		 * @return this
		 * @remark
		 * 设置元素实际占用大小（包括内边距和边框，但不包括滚动区域之外的大小）。
		 * 
		 * 此方法对可见和隐藏元素均有效。
		 * @example
		 * 设置 id=myP 的段落的大小。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p id=&quot;myP&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.get(&quot;myP&quot;).setSize({x:200,y:100});&lt;/pre&gt;
		 */</span>
		setSize: function(x, y) {
			var me = this,
			System = formatPoint(x, y);
		
			if (System.x != null) me.setWidth(System.x - Dom.calc(me.dom, 'bx+px'));
		
			if (System.y != null) me.setHeight(System.y - Dom.calc(me.dom, 'by+py'));
		
			return me;
		},
	
		<span id="Dom-prototype-setWidth">/**
		 * 获取当前 Dom 对象设置CSS宽度(width)属性的值（不带滚动条）。
		 * @param {Number} value 设置的宽度值。
		 * @return this
		 * @example
		 * 将所有段落的宽设为 20。
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).setWidth(20);&lt;/pre&gt;
		 */</span>
		setWidth: function(value) {
		
			this.dom.style.width = value &gt; 0 ? value + 'px': value &lt;= 0 ? '0px': value;
			return this;
		},
	
		<span id="Dom-prototype-setHeight">/**
		 * 获取当前 Dom 对象设置CSS高度(hidth)属性的值（不带滚动条）。
		 * @param {Number} value 设置的高度值。
		 * @return this
		 * @example
		 * 将所有段落的高设为 20。
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).setHeight(20);&lt;/pre&gt;
		 */</span>
		setHeight: function(value) {
	
			this.dom.style.height = value &gt; 0 ? value + 'px': value &lt;= 0 ? '0px': value;
			return this;
		},
	
		<span id="Dom-prototype-setOffset">/**
		 * 设置当前 Dom 对象相对父元素的偏移。
		 * @param {Point} offsetPoint 要设置的 x, y 对象。
		 * @return this
		 * @remark
		 * 此函数仅改变 CSS 中 left 和 top 的值。
		 * 如果当前对象的 position 是static，则此函数无效。
		 * 可以通过 {@link #setPosition} 强制修改 position, 或先调用 {@link Dom.movable} 来更改 position 。
		 * 
		 * @example
		 * 设置第一段的偏移。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;
		 * Dom.query(&quot;p:first&quot;).setOffset({ x: 10, y: 30 });
		 * &lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;left: 15, top: 15&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		setOffset: function(offsetPoint) {
		
			assert(Object.isObject(offsetPoint), &quot;Dom.prototype.setOffset(System): {System} 必须有 'x' 和 'y' 属性。&quot;, System);
			var s = this.dom.style;
			
			if(offsetPoint.y != null)
				s.top = offsetPoint.y + 'px';
				
			if(offsetPoint.x != null)
				s.left = offsetPoint.x + 'px';
			return this;
		},
	
		<span id="Dom-prototype-setPosition">/**
		 * 设置当前 Dom 对象的绝对位置。
		 * @param {Number/Point} x 要设置的水平坐标或一个包含 x、y 属性的对象。如果不设置，使用 null 。
		 * @param {Number} y 要设置的垂直坐标。如果不设置，使用 null 。
		 * @return this
		 * @remark
		 * 如果对象原先的position样式属性是static的话，会被改成relative来实现重定位。
		 * @example
		 * 设置第二段的位置。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;
		 * Dom.query(&quot;p:last&quot;).setPosition({ x: 10, y: 30 });
		 * &lt;/pre&gt;
		 */</span>
		setPosition: function(x, y) {
			var me = this,
				offset = me.getOffset().sub(me.getPosition()),
				offsetPoint = formatPoint(x, y);
		
			if (offsetPoint.y != null) offset.y += offsetPoint.y; 
			else offset.y = null;
		
			if (offsetPoint.x != null) offset.x += offsetPoint.x; 
			else offset.x = null;
		
			Dom.movable(me.dom);
		
			return me.setOffset(offset);
		},
	
		<span id="Dom-prototype-setScroll">/**
		 * 设置当前 Dom 对象的滚动条位置。
		 * @param {Number/Point} x 要设置的水平坐标或一个包含 x、y 属性的对象。如果不设置，使用 null 。
		 * @param {Number} y 要设置的垂直坐标。如果不设置，使用 null 。
		 * @return this
		 */</span>
		setScroll: function(x, y) {
			var elem = this.dom,
				offsetPoint = formatPoint(x, y);
		
			if (offsetPoint.x != null) elem.scrollLeft = offsetPoint.x;
			if (offsetPoint.y != null) elem.scrollTop = offsetPoint.y;
			return this;
	
		},
		
		<span id="Dom-prototype-delegate">/**
		 * 通过当前 Dom 对象代理执行子节点的事件。
		 * @param {String} selector 筛选子节点的选择器。
		 * @param {String} type 绑定的事件名。
		 * @param {Function} fn 绑定的事件监听器。
		 * @remark
		 * 这个函数会监听子节点的事件冒泡，并使用 CSS 选择器筛选子节点。
		 * 
		 * 这个方法是对 (@link #on} 的补充，比如有如下 HTML 代码:
		 * &lt;pre lang=&quot;htm&quot;&gt;
		 * &amp;amp;lt;body&amp;amp;gt;
		 * &amp;amp;lt;div class=&amp;quot;clickme&amp;quot;&amp;amp;gt;Click here&amp;amp;lt;/div&amp;amp;gt;
		 * &amp;amp;lt;/body&amp;amp;gt;
		 * &lt;/pre&gt;
		 * 
		 * 可以给这个元素绑定一个简单的click事件：
		 * &lt;pre&gt;
		 * Dom.query('.clickme').bind('click', function() {
		 * 	alert(&quot;Bound handler called.&quot;);
		 * });
		 * &lt;/pre&gt;
		 * 
		 * 使用 {@link #on} 时，函数会绑定一个事件处理函数，而以后再添加的对象则不会有。
		 * 而如果让父元素代理执行事件，则可以监听到动态增加的元素。比如:
		 * 
		 * &lt;pre&gt;
		 * document.delegate('.clickme', 'click', function() {
		 * 	alert(&quot;Bound handler called.&quot;);
		 * });
		 * &lt;/pre&gt;
		 * 
		 * 这时，无论是原先存在的，还是后来动态创建的节点，只要匹配了　.clickme ，就可以成功触发事件。
		 */</span>
		delegate: function(selector, eventName, handler){
			
			assert.isFunction(handler, &quot;Dom.prototype.delegate(selector, eventName, handler): {handler}  ~&quot;);
			
			this.on(eventName, function(e){
				var target = e.getTarget();
				if(e.getTarget().match(selector)){
					return handler.call(this, e, target);
				}
			});
			
		}

	})

	.implement({
		
		<span id="Dom-prototype-getStyle">/**
		 * 获取当前 Dom 对象指定属性的样式。
		 * @param {String} name 需要读取的样式名。允许使用 css 原名字或其骆驼规则。
		 * @return {String} 返回样式对应的值。如果此样式未设置过，返回其默认值。 
		 * @example
		 * 取得 id=myP 的段落的color样式属性的值。
		 * &lt;pre&gt;Dom.get(&quot;myP&quot;).getStyle(&quot;color&quot;);&lt;/pre&gt;
		 */</span>
		getStyle: function(name) {
		
			var elem = this.dom;
		
			assert.isString(name, &quot;Dom.prototype.getStyle(name): {name} ~&quot;);
			assert(elem.style, &quot;Dom.prototype.getStyle(name): 当 Dom 对象对应的节点不是元素，无法使用样式。&quot;);
		
			return elem.style[name = name.replace(rStyle, formatStyle)] || getStyle(elem, name);
		
		},
	
		/// #if CompactMode
		
		<span id="Dom-prototype-getOpacity">/**
		 * 获取当前 Dom 对象的透明度。
		 * @method
		 * @return {Number} 透明度。0 表示完全透明，  1 表示不透明。
		 * @remark 此函数等效于 getStyle('opacity', value);
		 */</span>
		getOpacity: 'opacity' in div.style ? function() {
			return styleNumber(this.dom, 'opacity');
		}: function() {
			return rOpacity.test(styleString(this.dom, 'filter')) ? parseInt(RegExp.$1) / 100: 1;
		},
	
		/// #else
		///
		/// getOpacity: function () {
		///
		/// 	return styleNumber(this.dom, 'opacity');
		///
		/// },
		
		/// #endif
		
		<span id="Dom-prototype-getAttr">/**
		 * 获取当前 Dom 对象的属性值。
		 * @param {String} name 要获取的属性名称。
		 * @return {String} 返回属性值。如果元素没有相应属性，则返回 null 。
	 	 * @example
	 	 * 返回文档中 id=&quot;img&quot; 的图像的src属性值。
	 	 * #####HTML:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;img id=&quot;img&quot; src=&quot;test.jpg&quot;/&amp;gt;&lt;/pre&gt;
	 	 * #####JavaScript:
	 	 * &lt;pre&gt;Dom.get(&quot;img&quot;).getAttr(&quot;src&quot;);&lt;/pre&gt;
	 	 * #####结果:
	 	 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;test.jpg&lt;/pre&gt;
		 */</span>
		getAttr: function(name) {
			return Dom.getAttr(this.dom, name);
		},
	
		<span id="Dom-prototype-hasClass">/**
		 * 检查当前 Dom 对象是否含有某个特定的类。
		 * @param {String} className 要判断的类名。只允许一个类名。
		 * @return {Boolean} 如果存在则返回 true。
		 * @example
		 * 隐藏包含有某个类的元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;div class=&quot;protected&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;div&quot;).on('click', function(){
		 * 	if ( this.hasClass(&quot;protected&quot;) )
		 * 		this.hide();
		 * });
		 * &lt;/pre&gt;
		 */</span>
		hasClass: function(className) {
			return Dom.hasClass(this.dom, className);
		},
	
		<span id="Dom-prototype-getText">/**
		 * 取得当前 Dom 对象内容。对于输入框则获取其输入的值。
		 * @return {String} 文本内容。对普通节点返回 textContent 属性, 对输入框返回 value 属性， 对普通节点返回 nodeValue 属性。
		 * @remark 
		 * 结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。
		 * @example
		 * 获取文本框中的值。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;input type=&quot;text&quot; value=&quot;some text&quot;/&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;input&quot;).getText();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[&quot;some text&quot;]&lt;/pre&gt;
		 */</span>
		getText: function() {
			return Dom.getText(this.dom);
		},
	
		<span id="Dom-prototype-getHtml">/**
		 * 取得当前 Dom 对象的html内容。
		 * @return {String} HTML 字符串。
		 * @example
		 * 获取 id=&quot;a&quot; 的节点的内部 html。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;div id=&quot;a&quot;&amp;gt;&amp;lt;p/&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;$Dom.query(&quot;a&quot;).getHtml();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&quot;&amp;lt;p/&amp;gt;&quot;&lt;/pre&gt;
		 */</span>
		getHtml: function() {
			assert(this.dom.nodeType === 1, &quot;Dom.prototype.getHtml(): 仅当 dom.nodeType === 1 时才能使用此函数。&quot;); 
			return this.dom.innerHTML;
		},
	
		<span id="Dom-prototype-getSize">/**
		 * 获取当前 Dom 对象的可视区域大小。包括 border 大小。
		 * @return {Point} 位置。
		 * @remark
		 * 此方法对可见和隐藏元素均有效。
		 * 
		 * 获取元素实际占用大小（包括内边距和边框）。
		 * @example
		 * 获取第一段落实际大小。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p:first&quot;).getSize();&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;{x=200,y=100}&lt;/pre&gt;
		 */</span>
		getSize: function() {
			var elem = this.dom;
		
			return new Point(elem.offsetWidth, elem.offsetHeight);
		},
	
		<span id="Dom-prototype-getWidth">/**
		 * 获取当前 Dom 对象的CSS width值。（不带滚动条）。
		 * @return {Number} 获取的值。
		 * 取得元素当前计算的宽度值（px）。
		 * @example
		 * 获取第一段的宽。
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).item(0).getWidth();&lt;/pre&gt;
		 * 
		 * 获取当前HTML文档宽度。
		 * &lt;pre&gt;document.getWidth();&lt;/pre&gt;
		 */</span>
		getWidth: function() {
			return styleNumber(this.dom, 'width');
		},
	
		<span id="Dom-prototype-getHeight">/**
		 * 获取当前 Dom 对象的CSS height值。（不带滚动条）。
		 * @return {Number} 获取的值。
		 * 取得元素当前计算的高度值（px）。
		 * @example
		 * 获取第一段的高。
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).item(0).getHeight();&lt;/pre&gt;
		 * 
		 * 获取当前HTML文档高度。
		 * &lt;pre&gt;document.getHeight();&lt;/pre&gt;
		 */</span>
		getHeight: function() {
			return styleNumber(this.dom, 'height');
		},
	
		<span id="Dom-prototype-getScrollSize">/**
		 * 获取当前 Dom 对象的滚动区域大小。
		 * @return {Point} 返回的对象包含两个整型属性：x 和 y。
		 * @remark
		 * getScrollSize 获取的值总是大于或的关于 getSize 的值。
		 * 
		 * 此方法对可见和隐藏元素均有效。
		 */</span>
		getScrollSize: function() {
			var elem = this.dom;
		
			return new Point(elem.scrollWidth, elem.scrollHeight);
		},
		
		<span id="Dom-prototype-getOffset">/**
		 * 获取当前 Dom 对象的相对位置。
		 * @return {Point} 返回的对象包含两个整型属性：x 和 y。
		 * @remark
		 * 此方法只对可见元素有效。
		 * 
		 * 获取匹配元素相对父元素的偏移。
		 * @example
		 * 获取第一段的偏移
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:&lt;pre&gt;
		 * var p = Dom.query(&quot;p&quot;).item(0);
		 * var offset = p.getOffset();
		 * trace( &quot;left: &quot; + offset.x + &quot;, top: &quot; + offset.y );
		 * &lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;left: 15, top: 15&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		getOffset: function() {
			// 如果设置过 left top ，这是非常轻松的事。
			var elem = this.dom, left = elem.style.left, top = elem.style.top;
		
			// 如果未设置过。
			if(!left || !top) {
		
				// 绝对定位需要返回绝对位置。
				if(styleString(elem, &quot;position&quot;) === 'absolute') {
					top = this.offsetParent();
					left = this.getPosition();
					if(!rBody.test(top.dom.nodeName))
						left = left.sub(top.getPosition());
					left.x -= styleNumber(elem, 'marginLeft') + styleNumber(top.dom, 'borderLeftWidth');
					left.y -= styleNumber(elem, 'marginTop') + styleNumber(top.dom, 'borderTopWidth');
		
					return left;
				}
		
				// 非绝对的只需检查 css 的style。
				left = getStyle(elem, 'left');
				top = getStyle(elem, 'top');
			}
		
			// 碰到 auto ， 空 变为 0 。
			return new Point(parseFloat(left) || 0, parseFloat(top) || 0);
		},
	
		<span id="Dom-prototype-getPosition">/**
		 * 获取当前 Dom 对象的绝对位置。
		 * @return {Point} 返回的对象包含两个整型属性：x 和 y。
		 * @remark
		 * 此方法只对可见元素有效。
		 * @example
		 * 获取第二段的偏移
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;
		 * var p = Dom.query(&quot;p&quot;).item(1);
		 * var position = p.getPosition();
		 * trace( &quot;left: &quot; + position.x + &quot;, top: &quot; + position.y );
		 * &lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;left: 0, top: 35&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		getPosition: div.getBoundingClientRect ? function() {
			var elem = this.dom, 
				bound = elem.getBoundingClientRect(),
				doc = getDocument(elem),
				html = doc.dom,
				htmlScroll = doc.getScroll();
			return new Point(bound.left + htmlScroll.x - html.clientLeft, bound.top + htmlScroll.y - html.clientTop);
		}: function() {
			var elem = this.dom, System = new Point(0, 0), t = elem.parentNode;
		
			if(styleString(elem, 'position') === 'fixed')
				return new Point(elem.offsetLeft, elem.offsetTop).add(document.getScroll());
		
			while(t &amp;&amp; !rBody.test(t.nodeName)) {
				System.x -= t.scrollLeft;
				System.y -= t.scrollTop;
				t = t.parentNode;
			}
			t = elem;
		
			while(elem &amp;&amp; !rBody.test(elem.nodeName)) {
				System.x += elem.offsetLeft;
				System.y += elem.offsetTop;
				if(navigator.isFirefox) {
					if(styleString(elem, 'MozBoxSizing') !== 'border-box') {
						add(elem);
					}
					var parent = elem.parentNode;
					if(parent &amp;&amp; styleString(parent, 'overflow') !== 'visible') {
						add(parent);
					}
				} else if(elem !== t &amp;&amp; navigator.isSafari) {
					add(elem);
				}
		
				if(styleString(elem, 'position') === 'fixed') {
					System = System.add(document.getScroll());
					break;
				}
				elem = elem.offsetParent;
			}
			if(navigator.isFirefox &amp;&amp; styleString(t, 'MozBoxSizing') !== 'border-box') {
				System.x -= styleNumber(t, 'borderLeftWidth');
				System.y -= styleNumber(t, 'borderTopWidth');
			}
		
			function add(elem) {
				System.x += styleNumber(elem, 'borderLeftWidth');
				System.y += styleNumber(elem, 'borderTopWidth');
			}
		
			return System;

		},
	
		<span id="Dom-prototype-getScroll">/**
		 * 获取当前 Dom 对象的滚动条的位置。
		 * @return {Point} 返回的对象包含两个整型属性：x 和 y。
		 * @remark
		 * 此方法对可见和隐藏元素均有效。
		 *
		 * @example
		 * 获取第一段相对滚动条顶部的偏移。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2nd Paragraph&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;
		 * var p = Dom.query(&quot;p&quot;).item(0);
		 * trace( &quot;scrollTop:&quot; + p.getScroll() );
		 * &lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;scrollTop: 0&amp;lt;/p&amp;gt;
		 * &lt;/pre&gt;
		 */</span>
		getScroll: getScroll

	}, 2)

	.implement({
		
		<span id="Dom-prototype-parent">/**
		 * 获取当前 Dom 对象的父节点对象。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 找到每个span元素的所有祖先元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;&amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;span&amp;gt;Hello Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.find(&quot;span&quot;).parent()&lt;/pre&gt;
		 */</span>
		parent: createTreeWalker('parentNode'),

		<span id="Dom-prototype-first">/**
		 * 获取当前 Dom 对象的第一个子节点对象。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 获取匹配的第二个元素
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt; This is just a test.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; So is this&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).first(1)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p&amp;gt; So is this&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		first: createTreeWalker('nextSibling', 'firstChild'),

		<span id="Dom-prototype-last">/**
		 * 获取当前 Dom 对象的最后一个子节点对象。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 获取匹配的第二个元素
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt; This is just a test.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; So is this&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).getChild(1)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p&amp;gt; So is this&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		last: createTreeWalker('previousSibling', 'lastChild'),

		<span id="Dom-prototype-next">/**
		 * 获取当前 Dom 对象的下一个相邻节点对象。取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 找到每个段落的后面紧邻的同辈元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;Hello Again&amp;lt;/p&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;And Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).getNext()&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p&amp;gt;Hello Again&amp;lt;/p&amp;gt;, &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;And Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; ]&lt;/pre&gt;
		 */</span>
		next: createTreeWalker('nextSibling'),

		<span id="Dom-prototype-prev">/**
		 * 获取当前 Dom 对象的上一个相邻的节点对象。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 找到每个段落紧邻的前一个同辈元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Hello Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;p&amp;gt;And Again&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).getPrevious()&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Hello Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; ]&lt;/pre&gt;
		 * 
		 * 找到每个段落紧邻的前一个同辈元素中类名为selected的元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;p class=&quot;selected&quot;&amp;gt;Hello Again&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;And Again&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).getPrevious(&quot;div&quot;)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p class=&quot;selected&quot;&amp;gt;Hello Again&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		prev: createTreeWalker('previousSibling'),

		<span id="Dom-prototype-children">/**
		 * 获取当前 Dom 对象的全部直接子节点。
		 * @param {Integer/String/Function/Boolean} [filter] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {NodeList} 返回满足要求的节点的列表。
		 * @example
		 * 
		 * 查找DIV中的每个子元素。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Hello Again&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;p&amp;gt;And Again&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;div&quot;).getChildren()&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;span&amp;gt;Hello Again&amp;lt;/span&amp;gt; ]&lt;/pre&gt;
		 * 
		 * 在每个div中查找 div。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;&amp;lt;p class=&quot;selected&quot;&amp;gt;Hello Again&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;And Again&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;div&quot;).getChildren(&quot;div&quot;)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p class=&quot;selected&quot;&amp;gt;Hello Again&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		children: function(args){
			return dir(this.dom.firstChild, 'nextSibling', args);
		},
		
		<span id="Dom-prototype-index">/**
		 * 获取当前 Dom 对象的在原节点的位置。
		 * @return {Number} 位置。从 0 开始。
		 */</span>
		index: 'nodeIndex' in div ? function(){
			return this.dom.nodeIndex;
		} : function() {
			var i = 0, elem = this.dom;
			while( elem = elem.previousSibling)
				if(elem.nodeType === 1)
					i++;
			return i;
		},
		
		<span id="Dom-prototype-getAll">/**
		 * 获取全部满足要求的节点的集合。
		 * @param {String} direction 遍历的方向方向，可以是以下值之一:
		 * 
		 * - **child**: 遍历当前全部子节点。如果是此关键字时，args 只能是 节点标签名。
		 * - **prev**: 遍历当前节点以前的节点。
		 * - **next**: 遍历当前节点以后的节点。
		 * - **parent**: 遍历当前节点的父节点。
		 * - **sibling**: 遍历当前节点的兄弟节点。
		 * 
		 * @param {Number/String/Function/Boolean} [args] 用于查找子元素的 CSS 选择器 或者 元素在Control对象中的索引 或者 用于筛选元素的过滤函数 或者 true 则同时接收包含文本节点的所有节点。
		 * @return {NodeList} 返回满足要求的节点的列表。
		 */</span>
		getAll: function(direction, args){
			switch(direction) {
				case 'child':
					return new DomList(this.dom.getElementsByTagName(args || '*'));
				case 'next':
					direction += 'Sibling';
					break;
				case 'prev':
					direction += 'iousSibling';
					break;
				case 'parent':
					direction += 'Node';
					break;
				case 'sibling':
					return this.getAll('prev').concat(this.getAll('next'));
			}
			return dir(this.dom[direction], direction, args);
		},

		<span id="Dom-prototype-find">/**
		 * 搜索所有与指定CSS表达式匹配的第一个元素。
		 * @param {String} selecter 用于查找的表达式。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 * @example
		 * 从所有的段落开始，进一步搜索下面的span元素。与Dom.find(&quot;p span&quot;)相同。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;, how are you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).find(&quot;span&quot;)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt; ]&lt;/pre&gt;
		 */</span>
		find: function(selector){
			assert.isString(selector, &quot;Dom.prototype.find(selector): selector ~。&quot;);
			var elem = this.dom, result;
			if(elem.nodeType !== 1) {
				return document.find.call(this, selector)
			}
			
			try{ 
				var oldId = elem.id, displayId = oldId;
				if(!oldId){
					elem.id = displayId = '__SELECTOR__';
					oldId = 0;
				}
				result = elem.querySelector('#' + displayId +' ' + selector);
			} catch(e) {
				result = query(selector, this)[0];
			} finally {
				if(oldId === 0){
					elem.id = null;	
				}
			}

			return result ? new Dom(result) : null;
		},
		
		<span id="Dom-prototype-query">/**
		 * 搜索所有与指定表达式匹配的元素。
		 * @param {String} 用于查找的表达式。
		 * @return {NodeList} 返回满足要求的节点的列表。
		 * @example
		 * 从所有的段落开始，进一步搜索下面的span元素。与Dom.query(&quot;p span&quot;)相同。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;, how are you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).query(&quot;span&quot;)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt; ]&lt;/pre&gt;
		 */</span>
		query: function(selector){
			assert.isString(selector, &quot;Dom.prototype.find(selector): selector ~。&quot;);
			assert(selector, &quot;Dom.prototype.find(selector): {selector} 不能为空。&quot;, selector);
			var elem = this.dom, result;
			
			if(elem.nodeType !== 1) {
				return document.query.call(this, selector)
			}
			
			try{ 
				var oldId = elem.id, displayId = oldId;
				if(!oldId){
					elem.id = displayId = '__SELECTOR__';
					oldId = 0;
				}
				result = elem.querySelectorAll('#' + displayId +' ' + selector);
			} catch(e) {
				result = query(selector, this);
			} finally {
				if(oldId === 0){
					elem.id = null;	
				}
			}
			
			
			
			return new DomList(result);
		},
			
		<span id="Dom-prototype-offsetParent">/**
		 * 获取用于让当前 Dom 对象定位的父对象。
		 * @return {Dom} 返回一个节点对象。如果不存在，则返回 null 。
		 */</span>
		offsetParent: function() {
			var me = this.dom;
			while(( me = me.offsetParent) &amp;&amp; !rBody.test(me.nodeName) &amp;&amp; styleString(me, &quot;position&quot;) === &quot;static&quot;);
			return new Dom(me || getDocument(this.dom).body);
		},
	 
		<span id="Dom-prototype-insert">/**
		 * 在某个位置插入一个HTML 。
		 * @param {String} where 插入地点。 
		 * 
		 * - **beforeBegin**: 节点外。 
		 * - **beforeEnd** 节点里。
		 * - **afterBegin** 节点外。
		 * - **afterEnd** 节点里。
		 * 
		 * @param {String/Node/Dom} html 要插入的内容。
		 * @return {Dom} 返回插入的新节点对象。
		 * 向每个匹配的元素内部前置内容。
		 * @example
		 * 向所有段落中前置一些HTML标记代码。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;I would like to say: &amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).insert(&quot;afterBegin&quot;,&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;I would like to say: &amp;lt;/p&amp;gt; ]&lt;/pre&gt;
		 */</span>
		insert: function(where, html) {
		
			assert(' afterEnd beforeBegin afterBegin beforeEnd '.indexOf(' ' + where + ' ') &gt;= 0, &quot;Dom.prototype.insert(where, html): {where} 必须是 beforeBegin、beforeEnd、afterBegin 或 afterEnd 。&quot;, where);
		
			var me = this,
				parentControl = me,
				refChild = me;
				
			html = Dom.parse(html, me.dom);
		
			switch (where) {
				case &quot;afterEnd&quot;:
					refChild = me.next(true);
				
					// 继续。
				case &quot;beforeBegin&quot;:
					parentControl = me.parent();
					assert(parentControl, &quot;Dom.prototype.insert(where, html): 节点无父节点时无法执行 insert({where})。&quot;, where);
					break;
				case &quot;afterBegin&quot;:
					refChild = me.first(true);
					break;
				default:
					refChild = null;
					break;
			}
		
			parentControl.insertBefore(html, refChild);
			return html;
		},
	
		<span id="Dom-prototype-append">/**
		 * 插入一个HTML 到末尾。
		 * @param {String/Node/Dom} html 要插入的内容。
		 * @return {Dom} 返回插入的新节点对象。
		 */</span>
		append: function(html) {
			html = Dom.parse(html, this);
			this.insertBefore(html, null);
			return html;
		},
		
		<span id="Dom-prototype-replaceWith">/**
		 * 将一个节点用另一个节点替换。
		 * @param {String/Node/Dom} html 用于将匹配元素替换掉的内容。
		 * @return {Element} 替换之后的新元素。
		 * 将所有匹配的元素替换成指定的HTML或DOM元素。
		 * @example
		 * 把所有的段落标记替换成加粗的标记。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;cruel&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;World&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;p&quot;).replaceWith(&quot;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&lt;/pre&gt;
		 *
		 * 用第一段替换第三段，可以发现他是移动到目标位置来替换，而不是复制一份来替换。
		 * #####HTML:&lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
		 * &amp;lt;div class=&amp;quot;inner first&amp;quot;&amp;gt;Hello&amp;lt;/div&amp;gt;
		 * &amp;lt;div class=&amp;quot;inner second&amp;quot;&amp;gt;And&amp;lt;/div&amp;gt;
		 * &amp;lt;div class=&amp;quot;inner third&amp;quot;&amp;gt;Goodbye&amp;lt;/div&amp;gt;
		 * &amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.find('.third').replaceWith(Dom.find('.first'));&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;
		 * &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
		 * &amp;lt;div class=&amp;quot;inner second&amp;quot;&amp;gt;And&amp;lt;/div&amp;gt;
		 * &amp;lt;div class=&amp;quot;inner first&amp;quot;&amp;gt;Hello&amp;lt;/div&amp;gt;
		 * &amp;lt;/div&amp;gt;
		 * &lt;/pre&gt;
		 */</span>
		replaceWith: function(html) {
			var elem;
			html = Dom.parse(html, this.dom);
			if (elem = this.parent()) {
				elem.insertBefore(html, this);
				elem.removeChild(this);
			}
			
			return html;
		},
	
		<span id="Dom-prototype-clone">/**
		 * 创建并返回当前 Dom 对象的副本。
		 * @param {Boolean} cloneEvent=false 是否复制事件。
		 * @param {Boolean} contents=true 是否复制子元素。
		 * @param {Boolean} keepId=false 是否复制 id 。
		 * @return {Dom} 新 Dom 对象。
		 *
		 * @example
		 * 克隆所有b元素（并选中这些克隆的副本），然后将它们前置到所有段落中。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&amp;lt;p&amp;gt;, how are you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;b&quot;).clone().prependTo(&quot;p&quot;);&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;, how are you?&amp;lt;/p&amp;gt;&lt;/pre&gt;
		 */</span>
		clone: function(cloneEvent, contents, keepId) {
		
			var elem = this.dom,
				clone = elem.cloneNode(contents = contents !== false);
			
			if(elem.nodeType === 1){
				if (contents) 
					for (var elemChild = elem.getElementsByTagName('*'), cloneChild = clone.getElementsByTagName('*'), i = 0; cloneChild[i]; i++) 
						cleanClone(elemChild[i], cloneChild[i], cloneEvent, keepId);
			
				cleanClone(elem, clone, cloneEvent, keepId);
			}
		
			return this.constructor === Dom ? new Dom(clone) : new this.constructor(clone);
		}
	 
	}, 3)

	.implement({
		
		<span id="Dom-prototype-match">/**
		 * 检查当前 Dom 对象是否符合指定的表达式。
		 * @param {String} String
		 * @return {Boolean} 如果匹配表达式就返回 true，否则返回  false 。
		 * @example
		 * 由于input元素的父元素是一个表单元素，所以返回true。
		 * #####HTML:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;form&amp;gt;&amp;lt;input type=&quot;checkbox&quot; /&amp;gt;&amp;lt;/form&amp;gt;&lt;/pre&gt;
		 * #####JavaScript:
		 * &lt;pre&gt;Dom.query(&quot;input[type='checkbox']&quot;).match(&quot;input&quot;)&lt;/pre&gt;
		 * #####结果:
		 * &lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;true&lt;/pre&gt;
		 */</span>
		match: function (selector) {
			return Dom.match(this.dom, selector);
		},
		
		<span id="Dom-prototype-isHidden">/**
		 * 判断当前元素是否是隐藏的。
		 * @return {Boolean} 当前元素已经隐藏返回 true，否则返回  false 。
		 */</span>
		isHidden: function(){
			return Dom.isHidden(this.dom) || styleString(this.dom, 'visibility') !== 'hidden';
		},
		
		<span id="Dom-prototype-hasChild">/**
		 * 判断一个节点是否有子节点。
		 * @param {Dom} [dom] 子节点。如果未传递此参数，则判断是否存在任何子节点。
		 * @param {Boolean} allowSelf=false 如果为 true，则当当前节点等于指定的节点时也返回 true 。
		 * @return {Boolean} 存在子节点则返回true 。
		 */</span>
		hasChild: function(dom, allowSelf) {
			var elem = this.dom;
			if(dom){
				dom = Dom.getNode(dom);
				return (allowSelf &amp;&amp; elem === dom) || Dom.hasChild(elem, dom);
			}
			
			return Dom.isEmpty(elem);
		}
		
	}, 4);
	
	/// #endif
	
	/// #region Dom.Document
	
	/**
	 * @class Dom.Document
	 */
	Dom.Document.implement({
		
		<span id="Dom-Document-prototype-dataField">/**
		 * 获取当前类对应的数据字段。
		 * @protected override
		 * @return {Object} 一个可存储数据的对象。
		 * @remark
		 * 此函数会在原生节点上创建一个 $data 属性以存储数据。
		 */</span>
		dataField: function(){
			return this.$data;
		},
		
		<span id="Dom-Document-prototype-append">/**
		 * 插入一个HTML 。
		 * @param {String/Dom} html 内容。
		 * @return {Node} 元素。
		 * 向每个匹配的元素内部追加内容。
        &lt;longdesc&gt;这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。&lt;/longdesc&gt;
        &lt;params name=&quot;content&quot; type=&quot;String, Element, Control&quot;&gt;
          要追加到目标中的内容
        &lt;/params&gt;
        @example
          向所有段落中追加一些HTML标记。
          #####HTML:&lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;&amp;lt;p&amp;gt;I would like to say: &amp;lt;/p&amp;gt;&lt;/pre&gt;
          #####JavaScript:&lt;pre&gt;Dom.query(&quot;p&quot;).append(&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&quot;);&lt;/pre&gt;
          #####结果:&lt;pre lang=&quot;htm&quot; format=&quot;none&quot;&gt;[ &amp;lt;p&amp;gt;I would like to say: &amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt; ]&lt;/pre&gt;
        
		 */</span>
		append: function(html) {
			return new Dom(this.body).append(html);
		},
		
		<span id="Dom-Document-prototype-insert">/**
		 * 插入一个HTML 。
		 * @param {String/Dom} html 内容。
		 * @return {Element} 元素。
		 */</span>
		insert: function(where, html) {
			return new Dom(this.body).insert(where, html);
		},
		
		<span id="Dom-Document-prototype-remove">/**
		 * 插入一个HTML 。
		 * @param {String/Dom} html 内容。
@return {Element} 元素。
		 */</span>
		remove: function() {
			var body = new Dom(this.body);
			body.remove.apply(body, arguments);
			return this;
		},
		
		find: function(selector){
			assert.isString(selector, &quot;Dom.prototype.find(selector): selector ~。&quot;);
			var result;
			try{
				result = this.querySelector(selector);
			} catch(e) {
				result = query(selector, this)[0];
			}
			return result ? new Dom(result) : null;
		},
		
		<span id="Dom-Document-prototype-query">/**
		 * 执行选择器。
		 * @method
		 * @param {String} selecter 选择器。 如 h2 .cls attr=value 。
		 * @return {Element/undefined} 节点。
		 */</span>
		query: function(selector){
			assert.isString(selector, &quot;Dom.prototype.find(selector): selector ~。&quot;);
			var result;
			try{
				result = this.querySelectorAll(selector);
			} catch(e) {
				result = query(selector, this);
			}
			return new DomList(result);
		},
		
		<span id="Dom-Document-prototype-getSize">/**
		 * 获取元素可视区域大小。包括 padding 和 border 大小。
		 * @method getSize
		 * @return {Point} 位置。
		 */</span>
		getSize: function() {
			var doc = this.dom;

			return new Point(doc.clientWidth, doc.clientHeight);
		},
		
		<span id="Dom-Document-prototype-getScrollSize">/**
		 * 获取滚动区域大小。
		 * @return {Point} 位置。
		 */</span>
		getScrollSize: function() {
			var html = this.dom, min = this.getSize(), body = this.body;

			return new Point(Math.max(html.scrollWidth, body.scrollWidth, min.x), Math.max(html.scrollHeight, body.scrollHeight, min.y));
		},

		<span id="Dom-Document-prototype-getPosition">/**
		 * 获取距父元素的偏差。
		 * @return {Point} 位置。
		 */</span>
		getPosition: getWindowScroll,

		<span id="Dom-Document-prototype-getScroll">/**
		 * 获取滚动条已滚动的大小。
		 * @return {Point} 位置。
		 */</span>
		getScroll: getWindowScroll,

		<span id="Dom-Document-prototype-setScroll">/**
		 * 滚到。
		 * @method setScroll
		 * @param {Number} x 坐标。
		 * @param {Number} y 坐标。
		 * @return {Document} this 。
		 * 传递参数值时，设置垂直滚动条顶部偏移为该值。
        &lt;longdesc&gt;此方法对可见和隐藏元素均有效。&lt;/longdesc&gt;
        &lt;params name=&quot;val&quot; type=&quot;String, Number&quot;&gt;
          设定垂直滚动条值
        &lt;/params&gt;
        @example
          设置相对滚动条顶部的偏移
          #####JavaScript:&lt;pre&gt;Dom.query(&quot;div.demo&quot;).setScroll(300);&lt;/pre&gt;
        
		 */</span>
		setScroll: function(x, y) {
			var doc = this, offsetPoint = formatPoint(x, y);
			if(offsetPoint.x == null)
				offsetPoint.x = doc.getScroll().x;
			if(offsetPoint.y == null)
				offsetPoint.y = doc.getScroll().y;
			(doc.defaultView || doc.parentWindow).scrollTo(offsetPoint.x, offsetPoint.y);

			return doc;
		}
		
	});

	/// #endif
	
	// 变量初始化。

	// 初始化 tagFix
	tagFix.optgroup = tagFix.option;
	tagFix.tbody = tagFix.tfoot = tagFix.colgroup = tagFix.caption = tagFix.thead;
	tagFix.th = tagFix.td;

	// 下列属性应该直接使用。
	map(&quot;checked selected disabled value innerHTML textContent className autofocus autoplay async controls hidden loop open required scoped compact nowrap ismap declare noshade multiple noresize defer readOnly tabIndex defaultValue accessKey defaultChecked cellPadding cellSpacing rowSpan colSpan frameBorder maxLength useMap contentEditable&quot;, function (value) {
		attrFix[value.toLowerCase()] = attrFix[value] = value;
	});

	textFix.INPUT = textFix.SELECT = textFix.TEXTAREA = 'value';

	textFix['#text'] = textFix['#comment'] = 'nodeValue';

	pep = Dom.Event.prototype;

	Dom.define(Dom, 'dom', 'scrollIntoView focus blur select click submit reset');
	Dom.addEvent('$default', eventObj);
	t = {};
	Dom.implement(map('on un trigger', function (name) {
		t[name] = function () {
			Dom.document[name].apply(Dom.document, arguments);
			return this;
		};

		return Dom.prototype[name];
	}, {}));
	
	t.once = Dom.prototype.once;
	Dom.Document.implement(t);

	t = DomList.prototype;

	map(&quot;shift pop unshift push include indexOf each forEach&quot;, function (value) {
		t[value] = ap[value];
	});

	map(&quot;filter slice splice reverse unique&quot;, function(value) {
		t[value] = function() {
			return new DomList(ap[value].apply(this, arguments));
		};
	});

	Point.format = formatPoint;
	
	document.dom = document.documentElement;

	/// #if CompactMode

	if(isStd) {

		/// #endif

		t = window.Event.prototype;
		t.stop = pep.stop
		t.getTarget = pep.getTarget;
		domReady = 'DOMContentLoaded';

		if (div.onmouseenter !== null) {

			Dom.addEvent('mouseenter mouseleave', {
				initEvent: function (e) {
					return this !== e.relatedTarget &amp;&amp; !Dom.hasChild(this.dom, e.relatedTarget);
				}
			});

		}

		/// #if CompactMode
	} else {

		eventObj.initEvent = function (e) {
			if (!e.stop) {
				e.target = e.srcElement;
				e.stop = pep.stop;
				e.getTarget = pep.getTarget;
				e.stopPropagation = pep.stopPropagation;
				e.preventDefault = pep.preventDefault;
			}
		};

		Dom.addEvent(&quot;click dblclick mousedown mouseup mouseover mouseenter mousemove mouseleave mouseout contextmenu selectstart selectend&quot;, {
			init: function (e) {
				if(!e.stop) {
					eventObj.initEvent(e);
					e.relatedTarget = e.fromElement === e.target ? e.toElement: e.fromElement;
					var dom = getDocument(e.target).dom;
					e.pageX = e.clientX + dom.scrollLeft;
					e.pageY = e.clientY + dom.scrollTop;
					e.layerX = e.x;
					e.layerY = e.y;
					// 1 ： 单击 2 ： 中键点击 3 ： 右击
					e.which = (e.button &amp; 1 ? 1: (e.button &amp; 2 ? 3: (e.button &amp; 4 ? 2: 0)));

				}
			}
		});

		Dom.addEvent(&quot;keydown keypress keyup&quot;,  {
			init: function (e) {
				if(!e.stop) {
					eventObj.initEvent(e);
					e.which = e.keyCode;
				}
			}
		});
		
		domReady = 'readystatechange';

		if (!('opacity' in div.style)) {
			styleFix.opacity = 'setOpacity';
		}
		
		Dom.propFix.OBJECT = 'outerHTML';

		attrFix.style = {

			get: function(elem, name) {
				return elem.style.cssText.toLowerCase();
			},
			set: function(elem, name, value) {
				elem.style.cssText = value;
			}
		};

		if(navigator.isQuirks) {

			attrFix.value = {

				node: function(elem, name) {
					assert(elem.getAttributeNode, &quot;Dom.prototype.getAttr(name, type): 当前元素不存在 getAttributeNode 方法&quot;);
					return elem.tagName === 'BUTTON' ? elem.getAttributeNode(name) || {
						value: ''
					}: elem;
				},
				
				get: function(elem, name) {
					return this.node(elem, name).value;
				},
				
				set: function(elem, name, value) {
					this.node(elem, name).value = value || '';
				}
			};

			attrFix.href = attrFix.src = attrFix.usemap = {

				get: function(elem, name) {
					return elem.getAttribute(name, 2);
				},

				set: function(elem, name, value) {
					elem.setAttribute(name, value);
				}
			};
	
			try {
	
				// 修复IE6 因 css 改变背景图出现的闪烁。
				document.execCommand(&quot;BackgroundImageCache&quot;, false, true);
			} catch(e) {
	
			}

		}

	}
	
	/// #endif

	<span id="Dom-ready">/**
	 * 设置在页面加载(不包含图片)完成时执行函数。
	 * @param {Functon} fn 当DOM加载完成后要执行的函数。
	 * @member Dom.ready
	 * @remark
	 * 允许你绑定一个在DOM文档载入完成后执行的函数。需要把页面中所有需要在 DOM 加载完成时执行的Dom.ready()操作符都包装到其中来。
	 * 
        @example
          当DOM加载完成后，执行其中的函数。
          #####JavaScript:&lt;pre&gt;Dom.ready(function(){
  // 文档就绪
});&lt;/pre&gt;
        
	 */</span>

	<span id="Dom-load">/**
	 * 设置在页面加载(包含图片)完成时执行函数。
	 * @param {Functon} fn 执行的函数。
	 * @member Dom.load
	 * @remark
	 * 允许你绑定一个在DOM文档载入完成后执行的函数。需要把页面中所有需要在 DOM 加载完成时执行的Dom.load()操作符都包装到其中来。
        @example
          当DOM加载完成后，执行其中的函数。
          #####JavaScript:&lt;pre&gt;Dom.load(function(){
  // 文档和引用的资源文件加载完成
});&lt;/pre&gt;
        
	 */</span>

	Dom.addEvent('domready domload', {});

	map('ready load', function(readyOrLoad, isLoad) {

		var isReadyOrIsLoad = isLoad ? 'isLoaded': 'isReady';

		// 设置 ready load
		Dom[readyOrLoad] = function (fn, bind) {
			
			// 忽略参数不是函数的调用。
			var isFn = Object.isFunction(fn);

			// 如果已载入，则直接执行参数。
			if(Dom[isReadyOrIsLoad]) {

				if (isFn)
					fn.call(bind);

			// 如果参数是函数。
			} else if (isFn) {

				document.on(readyOrLoad, fn, bind);

				// 触发事件。
				// 如果存在 JS 之后的 CSS 文件， 肯能导致 document.body 为空，此时延时执行 DomReady
			} else if (document.body) {

				// 如果 isReady, 则删除
				if(isLoad) {

					// 使用系统文档完成事件。
					isFn = Dom.window;
					fn = readyOrLoad;

					// 确保 ready 触发。
					Dom.ready();

				} else {
					isFn = Dom.document;
					fn = domReady;
				}

				eventObj.remove(isFn, fn, arguments.callee);

				// 先设置为已经执行。
				Dom[isReadyOrIsLoad] = true;

				// 触发事件。
				if (document.trigger(readyOrLoad, fn)) {

					// 删除事件。
					document.un(readyOrLoad);

				}
				
			} else {
				setTimeout(arguments.callee, 1);
			}

			return document;
		};

		readyOrLoad = 'dom' + readyOrLoad;
	});
	
	// 如果readyState 不是 complete, 说明文档正在加载。
	if(document.readyState !== &quot;complete&quot;) {

		// 使用系统文档完成事件。
		eventObj.add(Dom.document, domReady, Dom.ready);

		eventObj.add(Dom.window, 'load', Dom.load, false);

		/// #if CompactMode
		
		// 只对 IE 检查。
		if(!isStd) {

			// 来自 jQuery
			// 如果是 IE 且不是框架
			var topLevel = false;

			try {
				topLevel = window.frameElement == null;
			} catch(e) {
			}

			if(topLevel &amp;&amp; document.documentElement.doScroll) {

				/**
				 * 为 IE 检查状态。
				 * @private
				 */
				(function() {
					if(Dom.isReady) {
						return;
					}

					try {
						// http:// javascript.nwbox.com/IEContentLoaded/
						document.documentElement.doScroll(&quot;left&quot;);
					} catch(e) {
						setTimeout(arguments.callee, 1);
						return;
					}

					Dom.ready();
				})();
			}
		}

		/// #endif
	} else {
		setTimeout(Dom.load, 1);
	}
	
	div = null;

	extend(window, {

		Dom: Dom,

		Dom: Dom,

		Point: Point,
		
		DomList: DomList

	});

	Object.extendIf(window, {
		$: Dom.get,
		$$: Dom.query
	});
	
	/**
	 * @class
	 */

	/**
	 * 获取元素的文档。
	 * @param {Node} elem 元素。
	 * @return {Document} 文档。
	 */
	function getDocument(elem) {
		assert(elem &amp;&amp; (elem.nodeType || elem.setInterval), 'Dom.getDocument(elem): {elem} 必须是节点。', elem);
		return elem.ownerDocument || elem.document || elem;
	}

	/**
	 * 返回简单的遍历函数。
	 * @param {Boolean} getFirst 返回第一个还是返回所有元素。
	 * @param {String} next 获取下一个成员使用的名字。
	 * @param {String} first=next 获取第一个成员使用的名字。
	 * @return {Function} 遍历函数。
	 */
	function createTreeWalker(next, first) {
		first = first || next;
		return function(args) {
			var node = this.dom[first];
			
			// 如果存在 args 编译为函数。
			if(args){
				args = getFilter(args);
			}
			
			while(node) {
				if(args ? args.call(this, node) : node.nodeType === 1)
					return new Dom(node);
				node = node[next];
			}
			
			return null;
		};
	}
	
	function dir(node, next, args){
			
		// 如果存在 args 编译为函数。
		if(args){
			args = getFilter(args);
		}
		
		var r = new DomList;
		while(node){
			if(args ? args.call(this, node) : node.nodeType === 1)
				r.push(node);	
			node = node[next];
		}
		
		return r;
	}
	
	/**
	 * 获取一个选择器。
	 * @param {Number/Function/String/Boolean} args 参数。
	 * @return {Funtion} 函数。
	 */
	function getFilter(args) {
		
		// 如果存在 args，则根据不同的类型返回不同的检查函数。
		switch (typeof args) {
			
			// 数字返回一个计数器函数。
			case 'number':
				return function(elem) {
					return elem.nodeType === 1 &amp;&amp; --args &lt; 0;
				};
				
			// 字符串，表示选择器。
			case 'string':
				if(/^(?:[-\w:]|[^\x00-\xa0]|\\.)+$/.test(args)) {
					args = args.toUpperCase();
					return function(elem) {
						return elem.nodeType === 1 &amp;&amp; elem.tagName === args;
					};
				}
				return args === '*' ? null : function(elem) {
					return elem.nodeType === 1 &amp;&amp; Dom.match(elem, args);
				};
				
			// 布尔类型，而且是 true, 返回 Function.from(true)，  表示不过滤。
			case 'boolean':
				args = returnTrue;
				break;
			
		}

		assert.isFunction(args, &quot;Dom.prototype.getAll(direction, args): {args} 必须是一个函数、空、数字或字符串。&quot;, args);
		
		return args;
	}
	
	/**
	 * 删除由于拷贝导致的杂项。
	 * @param {Element} srcElem 源元素。
	 * @param {Element} destElem 目的元素。
	 * @param {Boolean} cloneEvent=true 是否复制数据。
	 * @param {Boolean} keepId=false 是否留下ID。
	 */
	function cleanClone(srcElem, destElem, cloneEvent, keepId) {

		if(!keepId &amp;&amp; destElem.removeAttribute)
			destElem.removeAttribute('id');

		/// #if CompactMode
		
		if(destElem.clearAttributes) {

			// IE 会复制 自定义事件， 清楚它。
			destElem.clearAttributes();
			destElem.mergeAttributes(srcElem);
			destElem.$data = null;

			if(srcElem.options) {
				Object.each(srcElem.options, function(value){
					destElem.options.seleced = value.seleced;
				});
			}
		}

		/// #endif

		if(cloneEvent !== false) {
			
		    // event 作为系统内部对象。事件的拷贝必须重新进行 on 绑定。
		    var event = srcElem.$data &amp;&amp; srcElem.$data.$event, dest;

		    if (event) {
		    	dest = new Dom(destElem);
			    for (cloneEvent in event)

				    // 对每种事件。
				    event[cloneEvent].handlers.forEach(function(handler) {

					    // 如果源数据的 target 是 src， 则改 dest 。
					    dest.on(cloneEvent, handler[0], handler[1].dom === srcElem ? dest : handler[1]);
				    });
			}
			
		}

		// 特殊属性复制。
		if( keepId = Dom.propFix[srcElem.tagName])
			destElem[keepId] = srcElem[keepId];
	}

	/**
	 * 清除节点的引用。
	 * @param {Element} elem 要清除的元素。
	 */
	function clean(elem) {

		// 删除自定义属性。
		if(elem.clearAttributes)
			elem.clearAttributes();

		// 删除事件。
		new Dom(elem).un();

		// 删除句柄，以删除双重的引用。
		elem.$data = null;

	}

	/**
	 * 到骆驼模式。
	 * @param {String} all 全部匹配的内容。
	 * @param {String} match 匹配的内容。
	 * @return {String} 返回的内容。
	 */
	function formatStyle(all, match) {
		return match ? match.toUpperCase(): styleFloat;
	}

	/**
	 * 读取样式字符串。
	 * @param {Element} elem 元素。
	 * @param {String} name 属性名。
	 * @return {String} 字符串。
	 */
	function styleString(elem, name) {
		assert.isElement(elem, &quot;Dom.styleString(elem, name): {elem} ~&quot;);
		return elem.style[name] || getStyle(elem, name);
	}

	/**
	 * 读取样式数字。
	 * @param {Object} elem 元素。
	 * @param {Object} name 属性名。
	 * @return {Number} 数字。
	 */
	function styleNumber(elem, name) {
		assert.isElement(elem, &quot;Dom.styleNumber(elem, name): {elem} ~&quot;);
		var value = parseFloat(elem.style[name]);
		if(!value &amp;&amp; value !== 0) {
			value = parseFloat(getStyle(elem, name));

			if(!value &amp;&amp; value !== 0) {
				if( name in styleFix) {
					
					var styles = {};
					for(var style in Dom.displayFix) {
						styles[style] = elem.style[style];
					}
					
					extend(elem.style, Dom.displayFix);
					value = parseFloat(getStyle(elem, name)) || 0;
					extend(elem.style, styles);
				} else {
					value = 0;
				}
			}
		}

		return value;
	}

	/**
	 * 转换参数为标准点。
	 * @param {Number} x X坐标。
	 * @param {Number} y Y坐标。
	 * @return {Object} {x:v, y:v}
	 */
	function formatPoint(x, y) {
		return x &amp;&amp; typeof x === 'object' ? x: {
			x: x,
			y: y
		};
	}

	/// #region Selector
	
	function throwError(string) {
		throw new SyntaxError('An invalid or illegal string was specified : &quot;' + string + '&quot;!');
	}

	function match(dom, selector){
		var r, i = -1;
		try{
			r = dom.parentNode.querySelectorAll(selector);
		} catch(e){
			r = query(selector, new Dom(dom.parentNode));
		}
		
		while(r[++i])
			if(r[i] === dom)
				return true;
		
		return false;
	}

	/**
	 * 使用指定的选择器代码对指定的结果集进行一次查找。
	 * @param {String} selector 选择器表达式。
	 * @param {DomList/Dom} result 上级结果集，将对此结果集进行查找。
	 * @return {DomList} 返回新的结果集。
	 */
	function query(selector, result) {

		var prevResult = result,
			rBackslash = /\\/g, 
			m, 
			key, 
			value, 
			lastSelector, 
			filterData;
		
		selector = selector.trim();

		// 解析分很多步进行，每次解析  selector 的一部分，直到解析完整个 selector 。
		while(selector) {
			
			// 保存本次处理前的选择器。
			// 用于在本次处理后检验 selector 是否有变化。
			// 如果没变化，说明 selector 不能被正确处理，即 selector 包含非法字符。
			lastSelector = selector;
			
			// 解析的第一步: 解析简单选择器
			
			// ‘*’ ‘tagName’ ‘.className’ ‘#id’
			if( m = /^(^|[#.])((?:[-\w\*]|[^\x00-\xa0]|\\.)+)/.exec(selector)) {
				
				// 测试是否可以加速处理。
				if(!m[1] || (result[m[1] === '#' ? 'getElementById' : 'getElementsByClassName'])) {
					selector = RegExp.rightContext;
					switch(m[1]) {
						
						// ‘#id’
						case '#':
							result = result.getElementById(m[2]);
							result = new DomList(result &amp;&amp; result.id === m[2] ? [result] : []);
							break;
							
						// ‘.className’
						case '.':
							result = new DomList(result.getElementsByClassName(m[2]));
							break;
							
						// ‘*’ ‘tagName’
						default:
							result = result.getAll('child', m[2].replace(rBackslash, &quot;&quot;));
							break;
								
					}
					
					// 如果仅仅为简单的 #id .className tagName 直接返回。
					if(!selector)
						break;
					
				// 无法加速，等待第四步进行过滤。
				} else {
					result = result.getAll('child');
				}
			
			// 解析的第二步: 解析父子关系操作符(比如子节点筛选)
			
			// ‘a&gt;b’ ‘a+b’ ‘a~b’ ‘a b’ ‘a *’
			} else if(m = /^\s*([\s&gt;+~&lt;])\s*(\*|(?:[-\w*]|[^\x00-\xa0]|\\.)*)/.exec(selector)) {
				selector = RegExp.rightContext;
				
				var value = m[2].replace(rBackslash, &quot;&quot;);
				
				switch(m[1]){
					case ' ':
						result = result.getAll('child', value);
						break;
						
					case '&gt;':
						result = result.children(value);
						break;
						
					case '+':
						result = result.next(value);
						break;
						
					case '~':
						result = result.getAll('next', value);
						break;
						
					case '&lt;':
						result = result.getAll('parent', value);
						break;
						
					default:
						throwError(m[1]);
				}
				
				// ‘a&gt;b’: m = ['&gt;', 'b']
				// ‘a&gt;.b’: m = ['&gt;', '']
				// result 始终实现了  Dom 接口，所以保证有 Dom.combinators 内的方法。

			// 解析的第三步: 解析剩余的选择器:获取所有子节点。第四步再一一筛选。
			} else {
				result = result.getAll('child');
			}
			
			// 解析的第四步: 筛选以上三步返回的结果。
	
			// ‘#id’ ‘.className’ ‘:filter’ ‘[attr’
			while(m = /^([#\.:]|\[\s*)((?:[-\w]|[^\x00-\xa0]|\\.)+)/.exec(selector)) {
				selector = RegExp.rightContext;
				value = m[2].replace(rBackslash, &quot;&quot;);
				
				// ‘#id’: m = ['#','id']
				
				// 筛选的第一步: 分析筛选器。
	
				switch (m[1]) {
	
					// ‘#id’
					case &quot;#&quot;:
						filterData = [&quot;id&quot;, &quot;=&quot;, value];
						break;
	
					// ‘.className’
					case &quot;.&quot;:
						filterData = [&quot;class&quot;, &quot;~=&quot;, value];
						break;
	
					// ‘:filter’
					case &quot;:&quot;:
						filterData = Dom.pseudos[value] || throwError(value);
						args = undefined;
	
						// ‘selector:nth-child(2)’
						if( m = /^\(\s*(&quot;([^&quot;]*)&quot;|'([^']*)'|[^\(\)]*(\([^\(\)]*\))?)\s*\)/.exec(selector)) {
							selector = RegExp.rightContext;
							args = m[3] || m[2] || m[1];
						}
						
						
						break;
	
					// ‘[attr’
					default:
						filterData = [value.toLowerCase()];
						
						// ‘selector[attr]’ ‘selector[attr=value]’ ‘selector[attr='value']’  ‘selector[attr=&quot;value&quot;]’    ‘selector[attr_=value]’
						if( m = /^\s*(?:(\S?=)\s*(?:(['&quot;])(.*?)\2|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/.exec(selector)) {
							selector = RegExp.rightContext;
							if(m[1]) {
								filterData[1] = m[1];
								filterData[2] = m[3] || m[4];
								filterData[2] = filterData[2] ? filterData[2].replace(/\\([0-9a-fA-F]{2,2})/g, toHex).replace(rBackslash, &quot;&quot;) : &quot;&quot;;
							}
						}
						break;
				}
		
				var args, 
					oldResult = result,
					i = 0,
					elem;
				
				// 筛选的第二步: 生成新的集合，并放入满足的节点。
				
				result = new DomList();
				if(filterData.call) {
					
					// 仅有 2 个参数则传入 oldResult 和 result
					if(filterData.length === 3){
						filterData(args, oldResult, result);
					} else {
						while(elem = oldResult[i++]) {
							if(filterData(elem, args))
								result.push(elem);
						}
					}
				} else {
					while(elem = oldResult[i++]){
						var actucalVal = Dom.getAttr(elem, filterData[0]),
							expectedVal = filterData[2],
							tmpResult;
						switch(filterData[1]){
							case undefined:
								tmpResult = actucalVal != null;
								break;
							case '=':
								tmpResult = actucalVal === expectedVal;
								break;
							case '~=':
								tmpResult = (' ' + actucalVal + ' ').indexOf(' ' + expectedVal + ' ') &gt;= 0;
								break;
							case '!=':
								tmpResult = actucalVal !== expectedVal;
								break;
							case '|=':
								tmpResult = ('-' + actucalVal + '-').indexOf('-' + expectedVal + '-') &gt;= 0;
								break;
							case '^=':
								tmpResult = actucalVal &amp;&amp; actucalVal.indexOf(expectedVal) === 0;
								break;
							case '$=':
								tmpResult = actucalVal &amp;&amp; actucalVal.substr(actucalVal.length - expectedVal.length) === expectedVal;
								break;
							case '*=':
								tmpResult = actucalVal &amp;&amp; actucalVal.indexOf(expectedVal) &gt;= 0;
								break;
							default:
								throw 'Not Support Operator : &quot;' + filterData[1] + '&quot;'
						}
						
						if(tmpResult){
							result.push(elem);	
						}
					}
				}
			}
			
			// 最后解析 , 如果存在，则继续。

			if( m = /^\s*,\s*/.exec(selector)) {
				selector = RegExp.rightContext;
				return result.concat(query(selector, prevResult));
			}


			if(lastSelector.length === selector.length){
				throwError(selector);
			}
		}
		
		return result;
	}
	
	function toHex(x, y) {
		return String.fromCharCode(parseInt(y, 16));
	}

	/// #endregion
	
})(this);</pre>
</body>
</html>
